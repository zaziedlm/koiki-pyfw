<!-- Generated by SpecStory -->

# 認証APIの設計提案 (2025-06-30 14:07Z)

_**User**_

このプロジェクトでは、最小限の認証APIが実装されています。不足している認証系APIを設計してください。どのようなAPIが必要と考えられますか？

---

_**Assistant**_

プロジェクトのコードを確認させていただきました。現在のエントリーポイントから、認証APIを含むWebアプリケーションの構成が見えます。一般的な認証システムに必要な最小限のAPIを設計いたします。

## 必要な認証系API

### 1. **基本認証API**
```python
# 新規ユーザー登録
POST /api/auth/register
# ログイン（トークン取得）
POST /api/auth/login
# ログアウト
POST /api/auth/logout
# トークン更新
POST /api/auth/refresh
```

### 2. **パスワード管理API**
```python
# パスワード変更
PUT /api/auth/password
# パスワードリセット要求
POST /api/auth/password/reset-request
# パスワードリセット実行
POST /api/auth/password/reset
```

### 3. **ユーザー情報API**
```python
# 現在のユーザー情報取得
GET /api/auth/me
# ユーザー情報更新
PUT /api/auth/me
# アカウント削除
DELETE /api/auth/me
```

### 4. **トークン管理API**
```python
# トークン検証
POST /api/auth/verify
# 全デバイスからログアウト
POST /api/auth/logout-all
# アクティブセッション一覧
GET /api/auth/sessions
```

## 推奨実装構成

````python
from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import HTTPBearer
from pydantic import BaseModel, EmailStr
from typing import Optional
import bcrypt
import jwt
from datetime import datetime, timedelta

router = APIRouter(prefix="/api/auth", tags=["authentication"])
security = HTTPBearer()

# データモデル
class UserRegister(BaseModel):
    email: EmailStr
    password: str
    username: str

class UserLogin(BaseModel):
    email: EmailStr
    password: str

class PasswordChange(BaseModel):
    current_password: str
    new_password: str

class PasswordResetRequest(BaseModel):
    email: EmailStr

# 基本認証エンドポイント
@router.post("/register")
async def register(user_data: UserRegister):
    """新規ユーザー登録"""
    # 実装ロジック
    pass

@router.post("/login")
async def login(credentials: UserLogin):
    """ログイン・トークン発行"""
    # 実装ロジック
    pass

@router.post("/logout")
async def logout(token: str = Depends(security)):
    """ログアウト"""
    # 実装ロジック
    pass

@router.post("/refresh")
async def refresh_token(token: str = Depends(security)):
    """リフレッシュトークン"""
    # 実装ロジック
    pass

@router.get("/me")
async def get_current_user(token: str = Depends(security)):
    """現在のユーザー情報取得"""
    # 実装ロジック
    pass
````

## セキュリティ考慮事項

1. **レートリミッター**: 既に実装されているようですが、ログインエンドポイントには特に厳しい制限を
2. **CORS設定**: フロントエンドとの連携用
3. **HTTPS強制**: 本番環境では必須
4. **JWT有効期限**: アクセストークン（短期）とリフレッシュトークン（長期）の使い分け
5. **パスワードハッシュ化**: bcryptまたはargon2使用

このような構成で、セキュアで実用的な認証システムが構築できます。既存のレートリミッターとの連携も考慮した設計になっています。

---

_**User**_

@workspace 現在のAPI実装も参考にして、不足APIを整備してください。

---

_**Assistant**_

現在のプロジェクト構造と実装を確認して、不足しているAPIを整備しましょう。

まず、現在の実装状況を確認します：

## 現在の実装状況

`auth.py`に認証APIが実装されており、`app/routers/todo_router.py`にToDo APIが実装されています。

## 不足しているAPIの整備

### 1. ユーザー管理API

````python
# app/routers/user_router.py
from fastapi import APIRouter, Depends, HTTPException, status
from typing import List, Optional
import structlog

from libkoiki.core.dependencies import DBSessionDep
from libkoiki.core.security import ActiveUserDep, AdminUserDep
from libkoiki.models.user import UserModel
from libkoiki.services.user_service import UserService
from app.schemas.user_schema import UserResponseSchema, UserUpdateSchema

router = APIRouter(prefix="/users", tags=["users"])
logger = structlog.get_logger()

@router.get("/me", response_model=UserResponseSchema)
async def get_current_user(
    current_user: ActiveUserDep
) -> UserResponseSchema:
    """現在のユーザー情報を取得"""
    return UserResponseSchema.model_validate(current_user)

@router.put("/me", response_model=UserResponseSchema)
async def update_current_user(
    user_update: UserUpdateSchema,
    db: DBSessionDep,
    current_user: ActiveUserDep,
    user_service: UserService = Depends()
) -> UserResponseSchema:
    """現在のユーザー情報を更新"""
    user_service.repository.set_session(db)
    updated_user = await user_service.update_user(current_user.id, user_update)
    if not updated_user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    return UserResponseSchema.model_validate(updated_user)

@router.get("/", response_model=List[UserResponseSchema])
async def list_users(
    db: DBSessionDep,
    admin_user: AdminUserDep,
    user_service: UserService = Depends(),
    skip: int = 0,
    limit: int = 100
) -> List[UserResponseSchema]:
    """ユーザー一覧を取得（管理者のみ）"""
    user_service.repository.set_session(db)
    users = await user_service.get_users(skip=skip, limit=limit)
    return [UserResponseSchema.model_validate(user) for user in users]

@router.get("/{user_id}", response_model=UserResponseSchema)
async def get_user(
    user_id: int,
    db: DBSessionDep,
    admin_user: AdminUserDep,
    user_service: UserService = Depends()
) -> UserResponseSchema:
    """特定のユーザー情報を取得（管理者のみ）"""
    user_service.repository.set_session(db)
    user = await user_service.get_user_by_id(user_id)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    return UserResponseSchema.model_validate(user)
````

### 2. ユーザースキーマ

````python
# app/schemas/user_schema.py
from pydantic import BaseModel, EmailStr
from typing import Optional
from datetime import datetime

class UserResponseSchema(BaseModel):
    """ユーザー情報レスポンス"""
    id: int
    username: str
    email: EmailStr
    is_active: bool
    is_superuser: bool
    created_at: datetime
    updated_at: datetime

    model_config = {"from_attributes": True}

class UserUpdateSchema(BaseModel):
    """ユーザー情報更新"""
    username: Optional[str] = None
    email: Optional[EmailStr] = None

class UserCreateSchema(BaseModel):
    """ユーザー作成"""
    username: str
    email: EmailStr
    password: str
````

### 3. 権限・ロール管理API

````python
# app/routers/role_router.py
from fastapi import APIRouter, Depends, HTTPException, status
from typing import List
import structlog

from libkoiki.core.dependencies import DBSessionDep
from libkoiki.core.security import AdminUserDep
from libkoiki.models.role import RoleModel
from libkoiki.models.permission import PermissionModel
from app.schemas.role_schema import RoleResponseSchema, RoleCreateSchema

router = APIRouter(prefix="/roles", tags=["roles"])
logger = structlog.get_logger()

@router.get("/", response_model=List[RoleResponseSchema])
async def list_roles(
    db: DBSessionDep,
    admin_user: AdminUserDep,
    skip: int = 0,
    limit: int = 100
) -> List[RoleResponseSchema]:
    """ロール一覧を取得（管理者のみ）"""
    # ロール取得ロジックの実装
    pass

@router.post("/", response_model=RoleResponseSchema)
async def create_role(
    role_data: RoleCreateSchema,
    db: DBSessionDep,
    admin_user: AdminUserDep
) -> RoleResponseSchema:
    """新しいロールを作成（管理者のみ）"""
    # ロール作成ロジックの実装
    pass
````

### 4. ヘルスチェック・監視API

````python
# app/routers/health_router.py
from fastapi import APIRouter, Depends, status
from typing import Dict, Any
import structlog
from datetime import datetime

from libkoiki.core.dependencies import DBSessionDep
from libkoiki.core.config import settings

router = APIRouter(prefix="/health", tags=["health"])
logger = structlog.get_logger()

@router.get("/")
async def health_check() -> Dict[str, Any]:
    """基本的なヘルスチェック"""
    return {
        "status": "healthy",
        "timestamp": datetime.utcnow().isoformat(),
        "version": "0.5.0"
    }

@router.get("/detailed")
async def detailed_health_check(db: DBSessionDep) -> Dict[str, Any]:
    """詳細なヘルスチェック（DB接続等を含む）"""
    try:
        # データベース接続チェック
        await db.execute("SELECT 1")
        db_status = "healthy"
    except Exception as e:
        logger.error("Database health check failed", error=str(e))
        db_status = "unhealthy"
    
    return {
        "status": "healthy" if db_status == "healthy" else "degraded",
        "timestamp": datetime.utcnow().isoformat(),
        "version": "0.5.0",
        "services": {
            "database": db_status,
            "api": "healthy"
        }
    }

@router.get("/metrics")
async def metrics() -> Dict[str, Any]:
    """アプリケーションメトリクス"""
    return {
        "uptime": "unknown",  # 実装時に起動時間を追跡
        "requests_total": "unknown",  # メトリクス収集の実装が必要
        "active_connections": "unknown"
    }
````

### 5. メインルーターにAPIを登録

````python
# app/main.py の修正
# ...existing code...
from app.routers import todo_router, user_router, role_router, health_router

# ...existing code...

# APIルーターの登録
app.include_router(
    auth_router,
    prefix=f"{settings.API_PREFIX}/auth"
)
app.include_router(
    todo_router.router,
    prefix=f"{settings.API_PREFIX}/todos"
)
app.include_router(
    user_router.router,
    prefix=f"{settings.API_PREFIX}/users"
)
app.include_router(
    role_router.router,
    prefix=f"{settings.API_PREFIX}/roles"
)
app.include_router(
    health_router.router,
    prefix=f"{settings.API_PREFIX}/health"
)
````

### 6. 管理者権限の依存性を追加

````python
# libkoiki/core/security.py の追加
# ...existing code...

async def get_admin_user(current_user: ActiveUserDep) -> UserModel:
    """管理者権限を持つユーザーを取得"""
    if not current_user.is_superuser:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Insufficient permissions"
        )
    return current_user

# 型エイリアス
AdminUserDep = Annotated[UserModel, Depends(get_admin_user)]
````

これらのAPIを追加することで、以下の機能が利用可能になります：

1. **ユーザー管理**: プロフィール更新、ユーザー一覧表示
2. **権限管理**: ロール・権限の管理
3. **監視・運用**: ヘルスチェック、メトリクス取得
4. **セキュリティ**: 管理者権限による適切なアクセス制御

現在の`design_kkfw_0.5.0.md`に記載されているフレームワーク設計に沿った実装となっており、``のコアライブラリと``のアプリケーション固有コードを適切に分離しています。

---

_**User**_

リフレッシュトークンAPIなど、詳細な認証系APIの追加設計を期待しています。高度な認証認可機能を備えるためのAPI設計でお願いします。

---

_**Assistant**_

現在の実装を確認し、高度な認証認可機能を備えた詳細なAPIを設計いたします。

## 1. 認証APIの拡張

````python
# ...existing code...

from typing import List, Optional
from datetime import datetime, timedelta
import secrets
import structlog
from fastapi import BackgroundTasks

# 新しいスキーマ
class RefreshTokenRequest(BaseModel):
    refresh_token: str

class PasswordChangeRequest(BaseModel):
    current_password: str
    new_password: str

class PasswordResetRequest(BaseModel):
    email: EmailStr

class PasswordResetConfirm(BaseModel):
    token: str
    new_password: str

class TwoFactorSetupResponse(BaseModel):
    secret: str
    qr_code_url: str
    backup_codes: List[str]

class TwoFactorVerifyRequest(BaseModel):
    code: str

class SessionInfo(BaseModel):
    id: str
    device_info: Optional[str] = None
    ip_address: str
    last_activity: datetime
    is_current: bool

logger = structlog.get_logger()

# リフレッシュトークン管理
@router.post("/refresh", response_model=TokenResponse)
async def refresh_access_token(
    request: RefreshTokenRequest,
    db: DBSessionDep,
    auth_service: AuthServiceDep
) -> TokenResponse:
    """リフレッシュトークンを使ってアクセストークンを更新"""
    try:
        token_data = await auth_service.verify_refresh_token(request.refresh_token)
        user = await auth_service.get_user_by_id(token_data.user_id)
        
        if not user or not user.is_active:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid refresh token"
            )
        
        # 新しいアクセストークンを生成
        access_token = await auth_service.create_access_token(user.id)
        
        # オプション: リフレッシュトークンのローテーション
        new_refresh_token = await auth_service.rotate_refresh_token(
            request.refresh_token, user.id
        )
        
        logger.info("Token refreshed", user_id=user.id)
        
        return TokenResponse(
            access_token=access_token,
            refresh_token=new_refresh_token,
            token_type="bearer"
        )
    except Exception as e:
        logger.error("Token refresh failed", error=str(e))
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid refresh token"
        )

# パスワード変更
@router.put("/password")
async def change_password(
    request: PasswordChangeRequest,
    current_user: ActiveUserDep,
    db: DBSessionDep,
    auth_service: AuthServiceDep
) -> dict:
    """ユーザーのパスワードを変更"""
    is_valid = await auth_service.verify_password(
        request.current_password, current_user.hashed_password
    )
    
    if not is_valid:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Invalid current password"
        )
    
    await auth_service.update_password(current_user.id, request.new_password)
    
    # 全てのセッションを無効化（セキュリティのため）
    await auth_service.invalidate_all_sessions(current_user.id)
    
    logger.info("Password changed", user_id=current_user.id)
    
    return {"message": "Password changed successfully"}

# パスワードリセット要求
@router.post("/password/reset-request")
async def request_password_reset(
    request: PasswordResetRequest,
    background_tasks: BackgroundTasks,
    db: DBSessionDep,
    auth_service: AuthServiceDep
) -> dict:
    """パスワードリセットトークンを送信"""
    user = await auth_service.get_user_by_email(request.email)
    
    if user:  # セキュリティのため、ユーザーが存在しなくても成功レスポンス
        reset_token = await auth_service.create_password_reset_token(user.id)
        
        # バックグラウンドでメール送信
        background_tasks.add_task(
            send_password_reset_email,
            user.email,
            reset_token
        )
        
        logger.info("Password reset requested", user_id=user.id)
    
    return {"message": "Password reset email sent if account exists"}

# パスワードリセット実行
@router.post("/password/reset-confirm")
async def confirm_password_reset(
    request: PasswordResetConfirm,
    db: DBSessionDep,
    auth_service: AuthServiceDep
) -> dict:
    """パスワードリセットトークンを使ってパスワードを変更"""
    try:
        user_id = await auth_service.verify_password_reset_token(request.token)
        await auth_service.update_password(user_id, request.new_password)
        await auth_service.invalidate_password_reset_token(request.token)
        await auth_service.invalidate_all_sessions(user_id)
        
        logger.info("Password reset completed", user_id=user_id)
        
        return {"message": "Password reset successfully"}
    except Exception:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Invalid or expired reset token"
        )
````

## 2. 二要素認証 (2FA) API

````python
from fastapi import APIRouter, Depends, HTTPException, status
import pyotp
import qrcode
import io
import base64
from typing import List

router = APIRouter(prefix="/2fa", tags=["two-factor-auth"])

@router.post("/setup", response_model=TwoFactorSetupResponse)
async def setup_two_factor(
    current_user: ActiveUserDep,
    db: DBSessionDep,
    auth_service: AuthServiceDep
) -> TwoFactorSetupResponse:
    """2FA設定を開始"""
    if current_user.two_factor_enabled:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Two-factor authentication is already enabled"
        )
    
    # 秘密鍵を生成
    secret = pyotp.random_base32()
    
    # QRコードを生成
    totp_uri = pyotp.totp.TOTP(secret).provisioning_uri(
        name=current_user.email,
        issuer_name="KOIKI-FW"
    )
    
    qr = qrcode.QRCode(version=1, box_size=10, border=5)
    qr.add_data(totp_uri)
    qr.make(fit=True)
    
    # QRコードを画像として生成
    img = qr.make_image(fill_color="black", back_color="white")
    buffer = io.BytesIO()
    img.save(buffer, format='PNG')
    qr_code_data = base64.b64encode(buffer.getvalue()).decode()
    
    # バックアップコードを生成
    backup_codes = [secrets.token_hex(8) for _ in range(10)]
    
    # 一時的に保存（確認後に有効化）
    await auth_service.store_temp_2fa_setup(
        current_user.id, secret, backup_codes
    )
    
    return TwoFactorSetupResponse(
        secret=secret,
        qr_code_url=f"data:image/png;base64,{qr_code_data}",
        backup_codes=backup_codes
    )

@router.post("/verify")
async def verify_two_factor_setup(
    request: TwoFactorVerifyRequest,
    current_user: ActiveUserDep,
    db: DBSessionDep,
    auth_service: AuthServiceDep
) -> dict:
    """2FA設定を確認・有効化"""
    temp_setup = await auth_service.get_temp_2fa_setup(current_user.id)
    
    if not temp_setup:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="No pending 2FA setup found"
        )
    
    totp = pyotp.TOTP(temp_setup.secret)
    
    if not totp.verify(request.code):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Invalid verification code"
        )
    
    # 2FAを有効化
    await auth_service.enable_two_factor(
        current_user.id, 
        temp_setup.secret, 
        temp_setup.backup_codes
    )
    
    await auth_service.cleanup_temp_2fa_setup(current_user.id)
    
    logger.info("2FA enabled", user_id=current_user.id)
    
    return {"message": "Two-factor authentication enabled successfully"}

@router.delete("/disable")
async def disable_two_factor(
    request: TwoFactorVerifyRequest,
    current_user: ActiveUserDep,
    db: DBSessionDep,
    auth_service: AuthServiceDep
) -> dict:
    """2FAを無効化"""
    if not current_user.two_factor_enabled:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Two-factor authentication is not enabled"
        )
    
    totp = pyotp.TOTP(current_user.two_factor_secret)
    
    if not totp.verify(request.code):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Invalid verification code"
        )
    
    await auth_service.disable_two_factor(current_user.id)
    
    logger.info("2FA disabled", user_id=current_user.id)
    
    return {"message": "Two-factor authentication disabled successfully"}
````

## 3. セッション管理API

````python
from fastapi import APIRouter, Depends, HTTPException, status, Request
from typing import List

router = APIRouter(prefix="/sessions", tags=["session-management"])

@router.get("/", response_model=List[SessionInfo])
async def list_active_sessions(
    current_user: ActiveUserDep,
    request: Request,
    db: DBSessionDep,
    auth_service: AuthServiceDep
) -> List[SessionInfo]:
    """アクティブなセッション一覧を取得"""
    current_session_id = request.headers.get("Authorization", "").split(" ")[-1]
    sessions = await auth_service.get_active_sessions(current_user.id)
    
    session_list = []
    for session in sessions:
        session_list.append(SessionInfo(
            id=session.id,
            device_info=session.device_info,
            ip_address=session.ip_address,
            last_activity=session.last_activity,
            is_current=session.token_hash == current_session_id
        ))
    
    return session_list

@router.delete("/{session_id}")
async def revoke_session(
    session_id: str,
    current_user: ActiveUserDep,
    db: DBSessionDep,
    auth_service: AuthServiceDep
) -> dict:
    """特定のセッションを無効化"""
    success = await auth_service.revoke_session(current_user.id, session_id)
    
    if not success:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Session not found"
        )
    
    logger.info("Session revoked", user_id=current_user.id, session_id=session_id)
    
    return {"message": "Session revoked successfully"}

@router.delete("/")
async def revoke_all_sessions(
    current_user: ActiveUserDep,
    db: DBSessionDep,
    auth_service: AuthServiceDep
) -> dict:
    """全てのセッションを無効化（現在のセッション以外）"""
    current_token = current_user.current_token  # 現在のトークンを保持
    
    await auth_service.revoke_all_sessions_except_current(
        current_user.id, 
        current_token
    )
    
    logger.info("All sessions revoked", user_id=current_user.id)
    
    return {"message": "All other sessions revoked successfully"}
````

## 4. 権限・ロール管理API

````python
from fastapi import APIRouter, Depends, HTTPException, status
from typing import List, Dict, Any

router = APIRouter(prefix="/permissions", tags=["permissions"])

class PermissionResponse(BaseModel):
    id: int
    name: str
    description: str
    resource: str
    action: str

class RoleResponse(BaseModel):
    id: int
    name: str
    description: str
    permissions: List[PermissionResponse]

class RoleAssignRequest(BaseModel):
    user_id: int
    role_ids: List[int]

@router.get("/", response_model=List[PermissionResponse])
async def list_permissions(
    admin_user: AdminUserDep,
    db: DBSessionDep,
    permission_service: PermissionServiceDep
) -> List[PermissionResponse]:
    """権限一覧を取得（管理者のみ）"""
    permissions = await permission_service.get_all_permissions()
    return [PermissionResponse.model_validate(p) for p in permissions]

@router.get("/roles", response_model=List[RoleResponse])
async def list_roles(
    admin_user: AdminUserDep,
    db: DBSessionDep,
    role_service: RoleServiceDep
) -> List[RoleResponse]:
    """ロール一覧を取得（管理者のみ）"""
    roles = await role_service.get_all_roles_with_permissions()
    return [RoleResponse.model_validate(r) for r in roles]

@router.post("/assign-roles")
async def assign_roles_to_user(
    request: RoleAssignRequest,
    admin_user: AdminUserDep,
    db: DBSessionDep,
    role_service: RoleServiceDep
) -> dict:
    """ユーザーにロールを割り当て（管理者のみ）"""
    await role_service.assign_roles_to_user(request.user_id, request.role_ids)
    
    logger.info(
        "Roles assigned", 
        target_user_id=request.user_id, 
        role_ids=request.role_ids,
        assigned_by=admin_user.id
    )
    
    return {"message": "Roles assigned successfully"}

@router.get("/user/{user_id}/effective", response_model=Dict[str, Any])
async def get_user_effective_permissions(
    user_id: int,
    admin_user: AdminUserDep,
    db: DBSessionDep,
    permission_service: PermissionServiceDep
) -> Dict[str, Any]:
    """ユーザーの実効権限を取得（管理者のみ）"""
    permissions = await permission_service.get_user_effective_permissions(user_id)
    
    return {
        "user_id": user_id,
        "permissions": permissions,
        "roles": await permission_service.get_user_roles(user_id)
    }
````

## 5. APIキー管理

````python
from fastapi import APIRouter, Depends, HTTPException, status
from typing import List, Optional
from datetime import datetime, timedelta

router = APIRouter(prefix="/api-keys", tags=["api-keys"])

class APIKeyCreate(BaseModel):
    name: str
    description: Optional[str] = None
    expires_at: Optional[datetime] = None
    permissions: List[str] = []

class APIKeyResponse(BaseModel):
    id: int
    name: str
    description: Optional[str]
    key_preview: str  # 最初の8文字のみ表示
    created_at: datetime
    expires_at: Optional[datetime]
    last_used_at: Optional[datetime]
    is_active: bool

@router.post("/", response_model=dict)
async def create_api_key(
    request: APIKeyCreate,
    current_user: ActiveUserDep,
    db: DBSessionDep,
    api_key_service: APIKeyServiceDep
) -> dict:
    """新しいAPIキーを作成"""
    api_key, key_value = await api_key_service.create_api_key(
        user_id=current_user.id,
        name=request.name,
        description=request.description,
        expires_at=request.expires_at,
        permissions=request.permissions
    )
    
    logger.info("API key created", user_id=current_user.id, key_id=api_key.id)
    
    return {
        "message": "API key created successfully",
        "key_id": api_key.id,
        "api_key": key_value,  # 一度だけ表示
        "warning": "この API キーは再表示されません。安全な場所に保存してください。"
    }

@router.get("/", response_model=List[APIKeyResponse])
async def list_api_keys(
    current_user: ActiveUserDep,
    db: DBSessionDep,
    api_key_service: APIKeyServiceDep
) -> List[APIKeyResponse]:
    """ユーザーのAPIキー一覧を取得"""
    keys = await api_key_service.get_user_api_keys(current_user.id)
    return [APIKeyResponse.model_validate(key) for key in keys]

@router.delete("/{key_id}")
async def revoke_api_key(
    key_id: int,
    current_user: ActiveUserDep,
    db: DBSessionDep,
    api_key_service: APIKeyServiceDep
) -> dict:
    """APIキーを無効化"""
    success = await api_key_service.revoke_api_key(current_user.id, key_id)
    
    if not success:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="API key not found"
        )
    
    logger.info("API key revoked", user_id=current_user.id, key_id=key_id)
    
    return {"message": "API key revoked successfully"}
````

## 6. メインアプリケーションへの統合

````python
# ...existing code...

from libkoiki.api.v1.endpoints import (
    auth, two_factor, sessions, permissions, api_keys
)

# APIルーターの登録
app.include_router(
    auth.router,
    prefix=f"{settings.API_PREFIX}/auth"
)
app.include_router(
    two_factor.router,
    prefix=f"{settings.API_PREFIX}/auth"
)
app.include_router(
    sessions.router,
    prefix=f"{settings.API_PREFIX}/auth"
)
app.include_router(
    permissions.router,
    prefix=f"{settings.API_PREFIX}/admin"
)
app.include_router(
    api_keys.router,
    prefix=f"{settings.API_PREFIX}/user"
)
````

この設計により、以下の高度な認証認可機能が実現できます：

1. **トークン管理**: リフレッシュトークン、ローテーション機能
2. **二要素認証**: TOTP、バックアップコード対応
3. **セッション管理**: マルチデバイス対応、個別無効化
4. **権限管理**: 細かい権限制御、ロールベース認可
5. **APIキー**: プログラマティックアクセス、スコープ制限
6. **セキュリティ**: パスワードリセット、アカウント保護

---

