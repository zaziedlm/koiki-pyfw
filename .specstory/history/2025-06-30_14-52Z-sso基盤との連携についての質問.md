<!-- Generated by SpecStory -->

# SSO基盤との連携についての質問 (2025-06-30 14:52Z)

_**User**_

認証系APIを充実されましたが、客先要望により、客先の認証SSO基盤サービスと連携することになりそうです。FastAPIの認証機能をベースとしていますが、SAML,Open connect id などで連携提携される、SSOサービスと組み合わせることは可能ですか？

---

_**Assistant**_

はい、KOIKI-FWの認証システムは、既存のSSO基盤サービスと連携することが可能です。FastAPIの柔軟な認証機構により、SAML、OpenID Connect、OAuth2.0などの企業向けSSOプロトコルとの統合が実現できます。

## SSO連携の実装方針

### 1. 認証フロー統合パターン

```mermaid
graph TD
    A[ユーザー] -->|1. アプリアクセス| B[KOIKI-FW]
    B -->|2. 認証チェック| C{認証済み?}
    C -->|No| D[SSO IdP へリダイレクト]
    D -->|3. SSO認証| E[企業SSO基盤]
    E -->|4. 認証結果 + トークン| F[KOIKI-FW]
    F -->|5. ユーザー情報同期| G[User Repository]
    F -->|6. 内部JWT発行| H[JWT Token]
    H -->|7. アプリケーション利用| A
```

### 2. アーキテクチャ統合

```
┌─────────────────────────────────────────────────────────────┐
│                    KOIKI-FW Application                     │
├─────────────────────────────────────────────────────────────┤
│ API Layer                                                   │
│  ├─ SSO Callback Endpoints                                  │
│  ├─ Traditional Auth Endpoints (Optional)                   │
│  └─ Protected API Endpoints                                 │
├─────────────────────────────────────────────────────────────┤
│ Authentication Middleware                                   │
│  ├─ JWT Token Verification                                  │
│  ├─ SSO Token Validation                                    │
│  └─ User Session Management                                 │
├─────────────────────────────────────────────────────────────┤
│ SSO Integration Layer                                       │
│  ├─ SAML Service Provider                                   │
│  ├─ OpenID Connect Client                                   │
│  ├─ OAuth2 Client                                           │
│  └─ User Provisioning Service                               │
├─────────────────────────────────────────────────────────────┤
│ User Management                                             │
│  ├─ User Repository (Local)                                 │
│  ├─ Role & Permission Management                            │
│  └─ User Synchronization                                    │
└─────────────────────────────────────────────────────────────┘
                                │
                                │ SSO Protocols
                                │
┌─────────────────────────────────────────────────────────────┐
│                    Enterprise SSO IdP                       │
│  ├─ SAML Identity Provider                                  │
│  ├─ OpenID Connect Provider                                 │
│  ├─ OAuth2 Authorization Server                             │
│  └─ User Directory (AD/LDAP)                                │
└─────────────────────────────────────────────────────────────┘
```

## SSO連携の実装

### 1. 設定の追加

````python
# libkoiki/core/config.py
class SSOSettings(BaseSettings):
    """SSO関連設定"""
    
    # SSO有効化フラグ
    SSO_ENABLED: bool = Field(default=False, env="SSO_ENABLED")
    
    # SAML設定
    SAML_ENABLED: bool = Field(default=False, env="SAML_ENABLED")
    SAML_IDP_METADATA_URL: Optional[str] = Field(default=None, env="SAML_IDP_METADATA_URL")
    SAML_SP_ENTITY_ID: Optional[str] = Field(default=None, env="SAML_SP_ENTITY_ID")
    SAML_ACS_URL: Optional[str] = Field(default=None, env="SAML_ACS_URL")
    SAML_CERTIFICATE_PATH: Optional[str] = Field(default=None, env="SAML_CERTIFICATE_PATH")
    SAML_PRIVATE_KEY_PATH: Optional[str] = Field(default=None, env="SAML_PRIVATE_KEY_PATH")
    
    # OpenID Connect設定
    OIDC_ENABLED: bool = Field(default=False, env="OIDC_ENABLED")
    OIDC_CLIENT_ID: Optional[str] = Field(default=None, env="OIDC_CLIENT_ID")
    OIDC_CLIENT_SECRET: Optional[str] = Field(default=None, env="OIDC_CLIENT_SECRET")
    OIDC_DISCOVERY_URL: Optional[str] = Field(default=None, env="OIDC_DISCOVERY_URL")
    OIDC_REDIRECT_URI: Optional[str] = Field(default=None, env="OIDC_REDIRECT_URI")
    OIDC_SCOPE: str = Field(default="openid profile email", env="OIDC_SCOPE")
    
    # OAuth2設定
    OAUTH2_ENABLED: bool = Field(default=False, env="OAUTH2_ENABLED")
    OAUTH2_CLIENT_ID: Optional[str] = Field(default=None, env="OAUTH2_CLIENT_ID")
    OAUTH2_CLIENT_SECRET: Optional[str] = Field(default=None, env="OAUTH2_CLIENT_SECRET")
    OAUTH2_AUTHORIZATION_URL: Optional[str] = Field(default=None, env="OAUTH2_AUTHORIZATION_URL")
    OAUTH2_TOKEN_URL: Optional[str] = Field(default=None, env="OAUTH2_TOKEN_URL")
    OAUTH2_USER_INFO_URL: Optional[str] = Field(default=None, env="OAUTH2_USER_INFO_URL")
    
    # ユーザー同期設定
    USER_AUTO_PROVISION: bool = Field(default=True, env="USER_AUTO_PROVISION")
    USER_SYNC_ATTRIBUTES: List[str] = Field(
        default=["email", "name", "groups", "roles"],
        env="USER_SYNC_ATTRIBUTES"
    )
    
    # セッション管理
    SSO_SESSION_TIMEOUT: int = Field(default=3600, env="SSO_SESSION_TIMEOUT")  # 1時間
    ALLOW_LOCAL_AUTH: bool = Field(default=True, env="ALLOW_LOCAL_AUTH")  # ローカル認証併用

class Settings(BaseSettings):
    # 既存設定...
    
    # SSO設定を統合
    sso: SSOSettings = SSOSettings()
````

### 2. OpenID Connect実装

````python
# libkoiki/sso/oidc_client.py
import httpx
from typing import Optional, Dict, Any
from urllib.parse import urlencode, urlparse, parse_qs
from jose import jwt, JWTError
import structlog

from libkoiki.core.config import settings
from libkoiki.core.exceptions import AuthenticationException

logger = structlog.get_logger(__name__)

class OIDCClient:
    """OpenID Connect クライアント"""
    
    def __init__(self):
        self.client_id = settings.sso.OIDC_CLIENT_ID
        self.client_secret = settings.sso.OIDC_CLIENT_SECRET
        self.discovery_url = settings.sso.OIDC_DISCOVERY_URL
        self.redirect_uri = settings.sso.OIDC_REDIRECT_URI
        self.scope = settings.sso.OIDC_SCOPE
        
        self._discovery_doc: Optional[Dict[str, Any]] = None
        self._jwks: Optional[Dict[str, Any]] = None
    
    async def get_discovery_document(self) -> Dict[str, Any]:
        """OpenID Connect Discovery Document を取得"""
        if self._discovery_doc is None:
            async with httpx.AsyncClient() as client:
                response = await client.get(self.discovery_url)
                response.raise_for_status()
                self._discovery_doc = response.json()
        return self._discovery_doc
    
    async def get_jwks(self) -> Dict[str, Any]:
        """JSON Web Key Set を取得"""
        if self._jwks is None:
            discovery_doc = await self.get_discovery_document()
            jwks_uri = discovery_doc.get("jwks_uri")
            
            async with httpx.AsyncClient() as client:
                response = await client.get(jwks_uri)
                response.raise_for_status()
                self._jwks = response.json()
        return self._jwks
    
    def get_authorization_url(self, state: str) -> str:
        """認証URLを生成"""
        discovery_doc = self.get_discovery_document()
        auth_endpoint = discovery_doc.get("authorization_endpoint")
        
        params = {
            "response_type": "code",
            "client_id": self.client_id,
            "redirect_uri": self.redirect_uri,
            "scope": self.scope,
            "state": state,
            "nonce": self._generate_nonce()
        }
        
        return f"{auth_endpoint}?{urlencode(params)}"
    
    async def exchange_code_for_tokens(self, code: str, state: str) -> Dict[str, Any]:
        """認証コードをトークンに交換"""
        discovery_doc = await self.get_discovery_document()
        token_endpoint = discovery_doc.get("token_endpoint")
        
        data = {
            "grant_type": "authorization_code",
            "code": code,
            "redirect_uri": self.redirect_uri,
            "client_id": self.client_id,
            "client_secret": self.client_secret,
        }
        
        async with httpx.AsyncClient() as client:
            response = await client.post(
                token_endpoint,
                data=data,
                headers={"Content-Type": "application/x-www-form-urlencoded"}
            )
            response.raise_for_status()
            return response.json()
    
    async def verify_id_token(self, id_token: str) -> Dict[str, Any]:
        """ID トークンを検証"""
        try:
            # JWKSを使用してトークンを検証
            jwks = await self.get_jwks()
            
            # トークンをデコード（検証なし）でheaderを取得
            unverified_header = jwt.get_unverified_header(id_token)
            
            # 適切なキーを見つける
            key = None
            for jwk in jwks.get("keys", []):
                if jwk.get("kid") == unverified_header.get("kid"):
                    key = jwk
                    break
            
            if not key:
                raise AuthenticationException("Unable to find appropriate key")
            
            # トークンを検証
            payload = jwt.decode(
                id_token,
                key,
                algorithms=["RS256"],
                audience=self.client_id,
                issuer=(await self.get_discovery_document()).get("issuer")
            )
            
            return payload
            
        except JWTError as e:
            logger.error("ID token verification failed", error=str(e))
            raise AuthenticationException("Invalid ID token")
    
    async def get_user_info(self, access_token: str) -> Dict[str, Any]:
        """ユーザー情報を取得"""
        discovery_doc = await self.get_discovery_document()
        userinfo_endpoint = discovery_doc.get("userinfo_endpoint")
        
        async with httpx.AsyncClient() as client:
            response = await client.get(
                userinfo_endpoint,
                headers={"Authorization": f"Bearer {access_token}"}
            )
            response.raise_for_status()
            return response.json()
    
    def _generate_nonce(self) -> str:
        """ノンスを生成"""
        import secrets
        return secrets.token_urlsafe(32)
````

### 3. SAML実装

````python
# libkoiki/sso/saml_client.py
from typing import Optional, Dict, Any
from lxml import etree
import base64
import zlib
from urllib.parse import urlencode
import structlog

from libkoiki.core.config import settings
from libkoiki.core.exceptions import AuthenticationException

logger = structlog.get_logger(__name__)

class SAMLClient:
    """SAML Service Provider クライアント"""
    
    def __init__(self):
        self.sp_entity_id = settings.sso.SAML_SP_ENTITY_ID
        self.acs_url = settings.sso.SAML_ACS_URL
        self.idp_metadata_url = settings.sso.SAML_IDP_METADATA_URL
        self.certificate_path = settings.sso.SAML_CERTIFICATE_PATH
        self.private_key_path = settings.sso.SAML_PRIVATE_KEY_PATH
        
        self._idp_metadata: Optional[Dict[str, Any]] = None
    
    async def get_idp_metadata(self) -> Dict[str, Any]:
        """IdP メタデータを取得"""
        if self._idp_metadata is None:
            async with httpx.AsyncClient() as client:
                response = await client.get(self.idp_metadata_url)
                response.raise_for_status()
                
                # XMLをパース
                root = etree.fromstring(response.content)
                
                # 必要な情報を抽出
                self._idp_metadata = {
                    "sso_url": self._extract_sso_url(root),
                    "entity_id": self._extract_entity_id(root),
                    "certificate": self._extract_certificate(root)
                }
        
        return self._idp_metadata
    
    def generate_saml_request(self, relay_state: Optional[str] = None) -> tuple[str, str]:
        """SAML認証リクエストを生成"""
        request_id = f"_{self._generate_id()}"
        
        saml_request = f"""
        <samlp:AuthnRequest
            xmlns:samlp="urn:oasis:names:tc:SAML:2.0:protocol"
            xmlns:saml="urn:oasis:names:tc:SAML:2.0:assertion"
            ID="{request_id}"
            Version="2.0"
            IssueInstant="{self._get_current_time()}"
            Destination="{self.idp_metadata['sso_url']}"
            AssertionConsumerServiceURL="{self.acs_url}"
            ProtocolBinding="urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST">
            <saml:Issuer>{self.sp_entity_id}</saml:Issuer>
            <samlp:NameIDPolicy
                Format="urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress"
                AllowCreate="true"/>
        </samlp:AuthnRequest>
        """
        
        # Base64エンコード
        encoded_request = base64.b64encode(saml_request.encode()).decode()
        
        # リダイレクトURLを生成
        idp_metadata = await self.get_idp_metadata()
        params = {
            "SAMLRequest": encoded_request,
            "RelayState": relay_state or ""
        }
        
        redirect_url = f"{idp_metadata['sso_url']}?{urlencode(params)}"
        
        return redirect_url, request_id
    
    def parse_saml_response(self, saml_response: str) -> Dict[str, Any]:
        """SAML レスポンスをパース"""
        try:
            # Base64デコード
            decoded_response = base64.b64decode(saml_response)
            
            # XMLをパース
            root = etree.fromstring(decoded_response)
            
            # 署名を検証
            if not self._verify_signature(root):
                raise AuthenticationException("Invalid SAML signature")
            
            # アサーションを抽出
            assertion = self._extract_assertion(root)
            
            # ユーザー情報を抽出
            user_info = self._extract_user_attributes(assertion)
            
            return user_info
            
        except Exception as e:
            logger.error("SAML response parsing failed", error=str(e))
            raise AuthenticationException("Invalid SAML response")
    
    def _extract_user_attributes(self, assertion_element) -> Dict[str, Any]:
        """アサーションからユーザー属性を抽出"""
        attributes = {}
        
        # NameID (通常はメールアドレス)
        name_id = assertion_element.find(".//{urn:oasis:names:tc:SAML:2.0:assertion}NameID")
        if name_id is not None:
            attributes["email"] = name_id.text
        
        # 属性ステートメント
        attr_statements = assertion_element.findall(
            ".//{urn:oasis:names:tc:SAML:2.0:assertion}AttributeStatement"
        )
        
        for attr_statement in attr_statements:
            attrs = attr_statement.findall(
                ".//{urn:oasis:names:tc:SAML:2.0:assertion}Attribute"
            )
            
            for attr in attrs:
                attr_name = attr.get("Name")
                attr_values = attr.findall(
                    ".//{urn:oasis:names:tc:SAML:2.0:assertion}AttributeValue"
                )
                
                if len(attr_values) == 1:
                    attributes[attr_name] = attr_values[0].text
                else:
                    attributes[attr_name] = [v.text for v in attr_values]
        
        return attributes
    
    def _generate_id(self) -> str:
        """一意のIDを生成"""
        import secrets
        return secrets.token_hex(16)
    
    def _get_current_time(self) -> str:
        """現在時刻をISO形式で取得"""
        from datetime import datetime
        return datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%SZ")
````

### 4. SSOエンドポイント

````python
# libkoiki/api/v1/endpoints/sso.py
from fastapi import APIRouter, Depends, HTTPException, Request, Form
from fastapi.responses import RedirectResponse
from typing import Optional, Dict, Any
import structlog

from libkoiki.core.config import settings
from libkoiki.core.security import create_access_token
from libkoiki.core.dependencies import get_db
from libkoiki.sso.oidc_client import OIDCClient
from libkoiki.sso.saml_client import SAMLClient
from libkoiki.sso.user_provisioning import UserProvisioningService
from libkoiki.schemas.token import Token

logger = structlog.get_logger(__name__)
router = APIRouter()

# SSO clients
oidc_client = OIDCClient() if settings.sso.OIDC_ENABLED else None
saml_client = SAMLClient() if settings.sso.SAML_ENABLED else None

@router.get("/sso/login")
async def sso_login(request: Request, provider: str = "oidc"):
    """SSO ログインを開始"""
    
    if provider == "oidc" and oidc_client:
        # OpenID Connect認証
        state = _generate_state()
        request.session["oauth_state"] = state
        
        auth_url = oidc_client.get_authorization_url(state)
        return RedirectResponse(url=auth_url)
    
    elif provider == "saml" and saml_client:
        # SAML認証
        relay_state = _generate_state()
        request.session["saml_relay_state"] = relay_state
        
        auth_url, request_id = saml_client.generate_saml_request(relay_state)
        request.session["saml_request_id"] = request_id
        
        return RedirectResponse(url=auth_url)
    
    else:
        raise HTTPException(status_code=400, detail="Unsupported SSO provider")

@router.get("/sso/callback/oidc")
async def oidc_callback(
    request: Request,
    code: str,
    state: str,
    db: DBSessionDep
):
    """OpenID Connect コールバック"""
    
    if not oidc_client:
        raise HTTPException(status_code=400, detail="OIDC not enabled")
    
    # State検証
    if state != request.session.get("oauth_state"):
        raise HTTPException(status_code=400, detail="Invalid state parameter")
    
    try:
        # トークンを取得
        token_response = await oidc_client.exchange_code_for_tokens(code, state)
        
        # ID トークンを検証
        id_token_payload = await oidc_client.verify_id_token(
            token_response["id_token"]
        )
        
        # ユーザー情報を取得
        user_info = await oidc_client.get_user_info(token_response["access_token"])
        
        # ユーザーをプロビジョニング
        user_provisioning = UserProvisioningService()
        user = await user_provisioning.provision_user_from_sso(
            user_info, "oidc", db
        )
        
        # 内部JWTを発行
        access_token = create_access_token(
            data={"sub": str(user.id)},
            expires_delta=timedelta(hours=settings.ACCESS_TOKEN_EXPIRE_MINUTES / 60)
        )
        
        logger.info("SSO login successful", 
                   user_id=user.id, 
                   email=user.email, 
                   provider="oidc")
        
        # フロントエンドにリダイレクト（トークンを含む）
        frontend_url = f"{settings.FRONTEND_URL}/sso-callback?token={access_token}"
        return RedirectResponse(url=frontend_url)
        
    except Exception as e:
        logger.error("OIDC callback failed", error=str(e))
        raise HTTPException(status_code=400, detail="Authentication failed")

@router.post("/sso/callback/saml")
async def saml_callback(
    request: Request,
    SAMLResponse: str = Form(...),
    RelayState: Optional[str] = Form(None),
    db: DBSessionDep
):
    """SAML コールバック"""
    
    if not saml_client:
        raise HTTPException(status_code=400, detail="SAML not enabled")
    
    # RelayState検証
    if RelayState != request.session.get("saml_relay_state"):
        raise HTTPException(status_code=400, detail="Invalid RelayState")
    
    try:
        # SAMLレスポンスを解析
        user_info = saml_client.parse_saml_response(SAMLResponse)
        
        # ユーザーをプロビジョニング
        user_provisioning = UserProvisioningService()
        user = await user_provisioning.provision_user_from_sso(
            user_info, "saml", db
        )
        
        # 内部JWTを発行
        access_token = create_access_token(
            data={"sub": str(user.id)},
            expires_delta=timedelta(hours=settings.ACCESS_TOKEN_EXPIRE_MINUTES / 60)
        )
        
        logger.info("SSO login successful", 
                   user_id=user.id, 
                   email=user.email, 
                   provider="saml")
        
        # フロントエンドにリダイレクト（トークンを含む）
        frontend_url = f"{settings.FRONTEND_URL}/sso-callback?token={access_token}"
        return RedirectResponse(url=frontend_url)
        
    except Exception as e:
        logger.error("SAML callback failed", error=str(e))
        raise HTTPException(status_code=400, detail="Authentication failed")

@router.get("/sso/logout")
async def sso_logout(request: Request, provider: str = "oidc"):
    """SSO ログアウト"""
    
    # セッションクリア
    request.session.clear()
    
    if provider == "oidc" and oidc_client:
        # OpenID Connect のログアウト
        discovery_doc = await oidc_client.get_discovery_document()
        end_session_endpoint = discovery_doc.get("end_session_endpoint")
        
        if end_session_endpoint:
            logout_url = f"{end_session_endpoint}?post_logout_redirect_uri={settings.FRONTEND_URL}"
            return RedirectResponse(url=logout_url)
    
    elif provider == "saml" and saml_client:
        # SAML のログアウト（SLOエンドポイントがある場合）
        # 実装は IdP の仕様に依存
        pass
    
    # デフォルトはフロントエンドにリダイレクト
    return RedirectResponse(url=settings.FRONTEND_URL)

def _generate_state() -> str:
    """状態パラメータを生成"""
    import secrets
    return secrets.token_urlsafe(32)
````

### 5. ユーザープロビジョニング

````python
# libkoiki/sso/user_provisioning.py
from typing import Dict, Any, Optional
from sqlalchemy.ext.asyncio import AsyncSession
import structlog

from libkoiki.models.user import UserModel
from libkoiki.repositories.user_repository import UserRepository
from libkoiki.core.config import settings

logger = structlog.get_logger(__name__)

class UserProvisioningService:
    """SSOユーザーのプロビジョニングサービス"""
    
    def __init__(self):
        self.user_repository = UserRepository()
    
    async def provision_user_from_sso(
        self, 
        user_info: Dict[str, Any], 
        provider: str,
        db: AsyncSession
    ) -> UserModel:
        """SSOユーザー情報からユーザーをプロビジョニング"""
        
        self.user_repository.set_session(db)
        
        # メールアドレスを取得
        email = self._extract_email(user_info, provider)
        if not email:
            raise ValueError("Email not found in SSO user info")
        
        # 既存ユーザーを検索
        existing_user = await self.user_repository.get_by_email(email)
        
        if existing_user:
            # 既存ユーザーの更新
            updated_user = await self._update_user_from_sso(
                existing_user, user_info, provider
            )
            logger.info("User updated from SSO", 
                       user_id=updated_user.id, 
                       email=email, 
                       provider=provider)
            return updated_user
        else:
            # 新規ユーザーの作成
            if settings.sso.USER_AUTO_PROVISION:
                new_user = await self._create_user_from_sso(user_info, provider)
                logger.info("User created from SSO", 
                           user_id=new_user.id, 
                           email=email, 
                           provider=provider)
                return new_user
            else:
                raise ValueError("Auto-provisioning is disabled")
    
    async def _create_user_from_sso(
        self, 
        user_info: Dict[str, Any], 
        provider: str
    ) -> UserModel:
        """SSOユーザー情報から新規ユーザーを作成"""
        
        # 基本情報を抽出
        email = self._extract_email(user_info, provider)
        full_name = self._extract_full_name(user_info, provider)
        
        # ユーザーオブジェクトを作成
        user_data = {
            "email": email,
            "full_name": full_name,
            "is_active": True,
            "is_superuser": False,
            "hashed_password": "",  # SSOユーザーはパスワード不要
            "sso_provider": provider,
            "sso_user_id": self._extract_sso_user_id(user_info, provider)
        }
        
        user = UserModel(**user_data)
        
        # ロールを割り当て
        await self._assign_roles_from_sso(user, user_info, provider)
        
        # データベースに保存
        created_user = await self.user_repository.create(user)
        
        return created_user
    
    async def _update_user_from_sso(
        self, 
        user: UserModel, 
        user_info: Dict[str, Any], 
        provider: str
    ) -> UserModel:
        """既存ユーザーをSSOユーザー情報で更新"""
        
        # 更新可能な属性をチェック
        if "name" in settings.sso.USER_SYNC_ATTRIBUTES:
            full_name = self._extract_full_name(user_info, provider)
            if full_name and full_name != user.full_name:
                user.full_name = full_name
        
        # SSOプロバイダ情報を更新
        user.sso_provider = provider
        user.sso_user_id = self._extract_sso_user_id(user_info, provider)
        
        # ロールを更新
        if "roles" in settings.sso.USER_SYNC_ATTRIBUTES:
            await self._assign_roles_from_sso(user, user_info, provider)
        
        # 最終ログイン時刻を更新
        user.last_login = datetime.utcnow()
        
        # データベースに保存
        updated_user = await self.user_repository.update(user)
        
        return updated_user
    
    def _extract_email(self, user_info: Dict[str, Any], provider: str) -> Optional[str]:
        """プロバイダ固有のメールアドレス抽出"""
        if provider == "oidc":
            return user_info.get("email")
        elif provider == "saml":
            return user_info.get("email") or user_info.get("nameID")
        return None
    
    def _extract_full_name(self, user_info: Dict[str, Any], provider: str) -> Optional[str]:
        """プロバイダ固有の氏名抽出"""
        if provider == "oidc":
            return user_info.get("name") or f"{user_info.get('given_name', '')} {user_info.get('family_name', '')}".strip()
        elif provider == "saml":
            return (user_info.get("displayName") or 
                   user_info.get("cn") or 
                   f"{user_info.get('givenName', '')} {user_info.get('sn', '')}".strip())
        return None
    
    def _extract_sso_user_id(self, user_info: Dict[str, Any], provider: str) -> Optional[str]:
        """プロバイダ固有のユーザーID抽出"""
        if provider == "oidc":
            return user_info.get("sub")
        elif provider == "saml":
            return user_info.get("nameID")
        return None
    
    async def _assign_roles_from_sso(
        self, 
        user: UserModel, 
        user_info: Dict[str, Any], 
        provider: str
    ):
        """SSOユーザー情報からロールを割り当て"""
        # グループやロール情報を抽出
        groups = self._extract_groups(user_info, provider)
        
        # グループからロールにマッピング
        roles = self._map_groups_to_roles(groups)
        
        # ロールを割り当て
        # 実装はRBAC設計に依存
        # user.roles = roles
        
        logger.info("Roles assigned from SSO", 
                   user_email=user.email, 
                   groups=groups, 
                   roles=roles)
    
    def _extract_groups(self, user_info: Dict[str, Any], provider: str) -> List[str]:
        """プロバイダ固有のグループ情報抽出"""
        groups = []
        
        if provider == "oidc":
            # OpenID Connect のグループ情報
            groups = user_info.get("groups", [])
            if isinstance(groups, str):
                groups = [groups]
        
        elif provider == "saml":
            # SAML のグループ情報
            groups = user_info.get("memberOf", [])
            if isinstance(groups, str):
                groups = [groups]
        
        return groups
    
    def _map_groups_to_roles(self, groups: List[str]) -> List[str]:
        """グループをアプリケーションロールにマッピング"""
        role_mapping = {
            "Administrators": "admin",
            "Users": "user",
            "Managers": "manager",
            "ReadOnly": "viewer"
        }
        
        roles = []
        for group in groups:
            if group in role_mapping:
                roles.append(role_mapping[group])
        
        # デフォルトロール
        if not roles:
            roles = ["user"]
        
        return roles
````

### 6. 統合認証ミドルウェア

````python
# libkoiki/core/auth_middleware.py
from typing import Optional
from fastapi import Request, HTTPException, status
from fastapi.security import HTTPBearer
import structlog

from libkoiki.core.config import settings
from libkoiki.core.security import verify_token
from libkoiki.sso.token_validator import SSOTokenValidator

logger = structlog.get_logger(__name__)

class UnifiedAuthMiddleware:
    """統合認証ミドルウェア（JWT + SSO）"""
    
    def __init__(self):
        self.http_bearer = HTTPBearer(auto_error=False)
        self.sso_validator = SSOTokenValidator()
    
    async def __call__(self, request: Request):
        """認証処理を実行"""
        
        # 公開エンドポイントのチェック
        if self._is_public_endpoint(request.url.path):
            return
        
        # 認証トークンの取得
        token = await self._extract_token(request)
        
        if not token:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Authentication required"
            )
        
        # トークンタイプの判定と検証
        user = await self._verify_token(token)
        
        if not user:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid token"
            )
        
        # リクエストにユーザー情報を設定
        request.state.user = user
    
    async def _extract_token(self, request: Request) -> Optional[str]:
        """リクエストからトークンを抽出"""
        
        # Authorization ヘッダーから取得
        credentials = await self.http_bearer(request)
        if credentials:
            return credentials.credentials
        
        # クッキーから取得（セッションベースSSO）
        session_token = request.cookies.get("sso_session")
        if session_token:
            return session_token
        
        return None
    
    async def _verify_token(self, token: str) -> Optional[UserModel]:
        """トークンを検証してユーザーを取得"""
        
        # 内部JWT トークンの検証
        try:
            user = await verify_token(token)
            if user:
                return user
        except Exception as e:
            logger.debug("Internal JWT verification failed", error=str(e))
        
        # SSOトークンの検証（有効な場合）
        if settings.sso.SSO_ENABLED:
            try:
                user = await self.sso_validator.verify_sso_token(token)
                if user:
                    return user
            except Exception as e:
                logger.debug("SSO token verification failed", error=str(e))
        
        return None
    
    def _is_public_endpoint(self, path: str) -> bool:
        """公開エンドポイントかどうかを判定"""
        public_paths = [
            "/auth/login",
            "/auth/register",
            "/auth/password-reset",
            "/sso/login",
            "/sso/callback",
            "/docs",
            "/openapi.json",
            "/health"
        ]
        
        return any(path.startswith(pub_path) for pub_path in public_paths)
````

## 運用上の考慮事項

### 1. 設定例

````bash
# .env.production
# SSO設定
SSO_ENABLED=true
ALLOW_LOCAL_AUTH=false  # 本番ではSSO必須

# OpenID Connect設定
OIDC_ENABLED=true
OIDC_CLIENT_ID=your-client-id
OIDC_CLIENT_SECRET=your-client-secret
OIDC_DISCOVERY_URL=https://your-idp.com/.well-known/openid-configuration
OIDC_REDIRECT_URI=https://your-app.com/api/v1/sso/callback/oidc

# SAML設定
SAML_ENABLED=true
SAML_SP_ENTITY_ID=https://your-app.com/saml/metadata
SAML_ACS_URL=https://your-app.com/api/v1/sso/callback/saml
SAML_IDP_METADATA_URL=https://your-idp.com/saml/metadata

# ユーザー同期設定
USER_AUTO_PROVISION=true
USER_SYNC_ATTRIBUTES=["email","name","groups","roles"]
````

### 2. 段階的移行戦略

1. **フェーズ1**: 既存認証とSSO並行運用
2. **フェーズ2**: SSO利用ユーザーの段階的移行
3. **フェーズ3**: 完全SSO移行（既存認証無効化）

### 3. セキュリティ考慮事項

- **トークン検証**: 必ずSSO プロバイダからの署名を検証
- **セッション管理**: 適切なセッションタイムアウト設定
- **監査ログ**: SSO認証イベントの完全記録
- **エラーハンドリング**: 認証エラーの適切な処理

## まとめ

KOIKI-FWは、既存の認証システムを拡張することで、企業のSSO基盤との統合が可能です。

**対応可能なSSOプロトコル**:
- ✅ OpenID Connect (OIDC)
- ✅ SAML 2.0
- ✅ OAuth 2.0
- ✅ カスタムSSO実装

**主な機能**:
- 🔄 既存認証との並行運用
- 🔄 自動ユーザープロビジョニング
- 🔄 ロール・権限の自動同期
- 🔄 統合認証ミドルウェア
- 🔄 包括的な監査ログ

この実装により、企業のSSO基盤を活用しながら、KOIKI-FWの柔軟な認証・認可システムを継続利用できます。

---

