<!-- Generated by SpecStory -->

# SSOサービスとの連携についての質問 (2025-07-07 16:26Z)

_**User**_

認証系APIを充実されましたが、客先要望により、客先の認証SSO基盤サービスと連携することになりそうです。FastAPIの認証機能をベースとしていますが、SAML,Open connect id などで連携提携される、SSOサービスと組み合わせることは可能ですか？

---

_**Assistant**_

はい、KOIKI-FWの認証システムはSAML、OpenID Connect（OIDC）などのSSOサービスと連携可能です。現在のJWT認証基盤を活用しながら、外部SSO認証を組み込む方法をご説明します。

## SSO連携アーキテクチャ

### 1. ハイブリッド認証システム

```python
# libkoiki/core/auth_providers.py
from enum import Enum
from typing import Optional, Dict, Any
from abc import ABC, abstractmethod

class AuthProvider(Enum):
    """認証プロバイダータイプ"""
    LOCAL = "local"           # 従来のメール/パスワード
    SAML = "saml"            # SAML SSO
    OIDC = "oidc"            # OpenID Connect
    OAUTH2 = "oauth2"        # OAuth2（Google、Microsoft等）

class BaseAuthProvider(ABC):
    """認証プロバイダーの基底クラス"""
    
    @abstractmethod
    async def authenticate(self, credentials: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """認証処理を実行"""
        pass
    
    @abstractmethod
    async def get_user_info(self, token: str) -> Optional[Dict[str, Any]]:
        """トークンからユーザー情報を取得"""
        pass
    
    @abstractmethod
    def get_login_url(self, redirect_uri: str) -> str:
        """ログイン用URLを生成"""
        pass
```

### 2. 統合認証サービス

```python
# libkoiki/services/sso_auth_service.py
from typing import Optional, Dict, Any, Tuple
import structlog
from sqlalchemy.ext.asyncio import AsyncSession

from libkoiki.core.auth_providers import AuthProvider, BaseAuthProvider
from libkoiki.services.user_service import UserService
from libkoiki.models.user import UserModel
from libkoiki.schemas.user import UserCreate, UserSSO
from libkoiki.core.security import create_access_token

logger = structlog.get_logger(__name__)

class SSOAuthService:
    """SSO認証の統合サービス"""
    
    def __init__(
        self,
        user_service: UserService,
        auth_providers: Dict[AuthProvider, BaseAuthProvider]
    ):
        self.user_service = user_service
        self.auth_providers = auth_providers
    
    async def authenticate_sso(
        self,
        provider: AuthProvider,
        credentials: Dict[str, Any],
        db: AsyncSession
    ) -> Tuple[Optional[UserModel], str]:
        """SSO認証を実行"""
        
        # 指定されたプロバイダーで認証
        auth_provider = self.auth_providers.get(provider)
        if not auth_provider:
            raise ValueError(f"Unsupported auth provider: {provider}")
        
        # 外部認証実行
        external_user_info = await auth_provider.authenticate(credentials)
        if not external_user_info:
            logger.warning("SSO authentication failed", provider=provider.value)
            return None, "Authentication failed"
        
        # ユーザー情報の同期
        user = await self._sync_user_from_sso(
            external_user_info, provider, db
        )
        
        if user:
            logger.info("SSO authentication successful", 
                       provider=provider.value, 
                       user_id=user.id,
                       email=user.email)
            return user, "success"
        
        return None, "User synchronization failed"
    
    async def _sync_user_from_sso(
        self,
        external_user_info: Dict[str, Any],
        provider: AuthProvider,
        db: AsyncSession
    ) -> Optional[UserModel]:
        """外部認証情報からユーザーを同期"""
        
        email = external_user_info.get("email")
        if not email:
            logger.error("Email not provided by SSO provider", 
                        provider=provider.value)
            return None
        
        # 既存ユーザーの確認
        existing_user = await self.user_service.get_user_by_email(email, db)
        
        if existing_user:
            # 既存ユーザーの情報を更新
            updated_user = await self._update_user_from_sso(
                existing_user, external_user_info, provider, db
            )
            return updated_user
        else:
            # 新規ユーザー作成
            new_user = await self._create_user_from_sso(
                external_user_info, provider, db
            )
            return new_user
    
    async def _create_user_from_sso(
        self,
        external_user_info: Dict[str, Any],
        provider: AuthProvider,
        db: AsyncSession
    ) -> Optional[UserModel]:
        """SSO情報から新規ユーザーを作成"""
        
        try:
            user_create = UserCreate(
                email=external_user_info["email"],
                full_name=external_user_info.get("name", ""),
                password="",  # SSO認証なのでパスワードは不要
                is_active=True,
                auth_provider=provider.value,
                external_user_id=external_user_info.get("sub") or external_user_info.get("id")
            )
            
            user = await self.user_service.create_user(user_create, db)
            
            logger.info("Created new user from SSO", 
                       provider=provider.value,
                       user_id=user.id,
                       email=user.email)
            
            return user
            
        except Exception as e:
            logger.error("Failed to create user from SSO",
                        provider=provider.value,
                        error=str(e))
            return None
    
    async def _update_user_from_sso(
        self,
        user: UserModel,
        external_user_info: Dict[str, Any],
        provider: AuthProvider,
        db: AsyncSession
    ) -> UserModel:
        """SSO情報から既存ユーザーを更新"""
        
        # 必要に応じて情報を更新
        if external_user_info.get("name") and external_user_info["name"] != user.full_name:
            user.full_name = external_user_info["name"]
        
        # プロバイダー情報の更新
        user.auth_provider = provider.value
        user.external_user_id = external_user_info.get("sub") or external_user_info.get("id")
        
        db.add(user)
        await db.commit()
        await db.refresh(user)
        
        return user
```

## SAML連携の実装

### 1. SAMLプロバイダー

```python
# libkoiki/core/auth_providers/saml_provider.py
import xml.etree.ElementTree as ET
from onelogin.saml2.auth import OneLogin_Saml2_Auth
from onelogin.saml2.utils import OneLogin_Saml2_Utils
from typing import Optional, Dict, Any
from fastapi import Request

from libkoiki.core.auth_providers import BaseAuthProvider
from libkoiki.core.config import settings

class SAMLAuthProvider(BaseAuthProvider):
    """SAML認証プロバイダー"""
    
    def __init__(self):
        self.saml_settings = self._get_saml_settings()
    
    def _get_saml_settings(self) -> Dict[str, Any]:
        """SAML設定を構築"""
        return {
            "sp": {
                "entityId": settings.SAML_SP_ENTITY_ID,
                "assertionConsumerService": {
                    "url": f"{settings.BASE_URL}/api/v1/auth/saml/acs",
                    "binding": "urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST"
                },
                "singleLogoutService": {
                    "url": f"{settings.BASE_URL}/api/v1/auth/saml/sls",
                    "binding": "urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect"
                },
                "NameIDFormat": "urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress",
                "x509cert": settings.SAML_SP_CERT,
                "privateKey": settings.SAML_SP_PRIVATE_KEY
            },
            "idp": {
                "entityId": settings.SAML_IDP_ENTITY_ID,
                "singleSignOnService": {
                    "url": settings.SAML_IDP_SSO_URL,
                    "binding": "urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect"
                },
                "singleLogoutService": {
                    "url": settings.SAML_IDP_SLO_URL,
                    "binding": "urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect"
                },
                "x509cert": settings.SAML_IDP_CERT
            }
        }
    
    async def authenticate(self, credentials: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """SAML認証処理"""
        request = credentials.get("request")
        if not request:
            return None
        
        # OneLogin SAML2ライブラリを使用
        saml_auth = OneLogin_Saml2_Auth(
            self._prepare_request(request),
            self.saml_settings
        )
        
        # SAMLレスポンスの処理
        saml_auth.process_response()
        
        if saml_auth.is_authenticated():
            user_info = {
                "email": saml_auth.get_nameid(),
                "name": saml_auth.get_attribute("http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name"),
                "groups": saml_auth.get_attribute("http://schemas.microsoft.com/ws/2008/06/identity/claims/groups"),
                "sub": saml_auth.get_nameid()
            }
            return user_info
        
        return None
    
    def get_login_url(self, redirect_uri: str) -> str:
        """SAMLログインURLを生成"""
        return OneLogin_Saml2_Utils.get_self_url() + "?sso"
    
    def _prepare_request(self, request: Request) -> Dict[str, Any]:
        """FastAPIリクエストをOneLogin形式に変換"""
        return {
            "https": "on" if request.url.scheme == "https" else "off",
            "http_host": request.url.hostname,
            "server_port": request.url.port,
            "script_name": request.url.path,
            "get_data": dict(request.query_params),
            "post_data": {}  # POSTデータは別途処理
        }
```

### 2. SAMLエンドポイント

```python
# libkoiki/api/v1/endpoints/auth_saml.py
from fastapi import APIRouter, Request, HTTPException, Depends, Form
from fastapi.responses import RedirectResponse
from sqlalchemy.ext.asyncio import AsyncSession
from typing import Optional
import structlog

from libkoiki.core.auth_providers import AuthProvider
from libkoiki.services.sso_auth_service import SSOAuthService
from libkoiki.core.security import create_access_token
from libkoiki.db.session import get_db
from libkoiki.api.dependencies import get_sso_auth_service

logger = structlog.get_logger(__name__)
router = APIRouter()

@router.get("/saml/login")
async def saml_login(
    request: Request,
    sso_service: SSOAuthService = Depends(get_sso_auth_service)
):
    """SAML認証開始"""
    try:
        # SAML認証プロバイダーを取得
        saml_provider = sso_service.auth_providers.get(AuthProvider.SAML)
        if not saml_provider:
            raise HTTPException(status_code=500, detail="SAML provider not configured")
        
        # SAMLログインURLを生成
        login_url = saml_provider.get_login_url(
            redirect_uri=str(request.url_for("saml_callback"))
        )
        
        return RedirectResponse(url=login_url)
        
    except Exception as e:
        logger.error("SAML login initiation failed", error=str(e))
        raise HTTPException(status_code=500, detail="SAML login failed")

@router.post("/saml/acs")
async def saml_callback(
    request: Request,
    SAMLResponse: str = Form(...),
    RelayState: Optional[str] = Form(None),
    db: AsyncSession = Depends(get_db),
    sso_service: SSOAuthService = Depends(get_sso_auth_service)
):
    """SAML認証コールバック（ACS: Assertion Consumer Service）"""
    try:
        # SAML認証実行
        user, message = await sso_service.authenticate_sso(
            provider=AuthProvider.SAML,
            credentials={
                "request": request,
                "saml_response": SAMLResponse,
                "relay_state": RelayState
            },
            db=db
        )
        
        if not user:
            logger.warning("SAML authentication failed", message=message)
            raise HTTPException(status_code=401, detail="Authentication failed")
        
        # JWTトークンを生成
        access_token = create_access_token(
            data={"sub": str(user.id), "email": user.email}
        )
        
        # フロントエンドにリダイレクト（トークンを含む）
        frontend_url = f"{settings.FRONTEND_URL}/auth/callback?token={access_token}"
        return RedirectResponse(url=frontend_url)
        
    except Exception as e:
        logger.error("SAML callback processing failed", error=str(e))
        raise HTTPException(status_code=500, detail="Authentication processing failed")

@router.get("/saml/sls")
async def saml_logout(
    request: Request,
    SAMLRequest: Optional[str] = None,
    SAMLResponse: Optional[str] = None,
    RelayState: Optional[str] = None
):
    """SAML単一ログアウト"""
    try:
        # SAMLログアウト処理
        # 実装は要件に応じて調整
        
        # フロントエンドのログアウトページにリダイレクト
        return RedirectResponse(url=f"{settings.FRONTEND_URL}/logout")
        
    except Exception as e:
        logger.error("SAML logout failed", error=str(e))
        raise HTTPException(status_code=500, detail="Logout failed")

@router.get("/saml/metadata")
async def saml_metadata(
    sso_service: SSOAuthService = Depends(get_sso_auth_service)
):
    """SAML メタデータ提供"""
    try:
        saml_provider = sso_service.auth_providers.get(AuthProvider.SAML)
        if not saml_provider:
            raise HTTPException(status_code=500, detail="SAML provider not configured")
        
        # メタデータXMLを生成
        metadata_xml = saml_provider.generate_metadata()
        
        return Response(
            content=metadata_xml,
            media_type="application/xml",
            headers={"Content-Disposition": "attachment; filename=metadata.xml"}
        )
        
    except Exception as e:
        logger.error("SAML metadata generation failed", error=str(e))
        raise HTTPException(status_code=500, detail="Metadata generation failed")
```

## OpenID Connect連携の実装

### 1. OIDCプロバイダー

```python
# libkoiki/core/auth_providers/oidc_provider.py
from authlib.integrations.httpx_client import AsyncOAuth2Client
from authlib.oidc.core import CodeIDToken
from typing import Optional, Dict, Any
import httpx
import structlog

from libkoiki.core.auth_providers import BaseAuthProvider
from libkoiki.core.config import settings

logger = structlog.get_logger(__name__)

class OIDCAuthProvider(BaseAuthProvider):
    """OpenID Connect認証プロバイダー"""
    
    def __init__(self):
        self.client_id = settings.OIDC_CLIENT_ID
        self.client_secret = settings.OIDC_CLIENT_SECRET
        self.discovery_url = settings.OIDC_DISCOVERY_URL
        self.redirect_uri = f"{settings.BASE_URL}/api/v1/auth/oidc/callback"
        
        # OpenID Connect設定を取得
        self.oidc_config = None
        self.jwks = None
    
    async def _get_oidc_config(self) -> Dict[str, Any]:
        """OpenID Connect設定を取得"""
        if not self.oidc_config:
            async with httpx.AsyncClient() as client:
                response = await client.get(self.discovery_url)
                response.raise_for_status()
                self.oidc_config = response.json()
        
        return self.oidc_config
    
    async def _get_jwks(self) -> Dict[str, Any]:
        """JWKS（JSON Web Key Set）を取得"""
        if not self.jwks:
            config = await self._get_oidc_config()
            async with httpx.AsyncClient() as client:
                response = await client.get(config["jwks_uri"])
                response.raise_for_status()
                self.jwks = response.json()
        
        return self.jwks
    
    async def authenticate(self, credentials: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """OIDC認証処理"""
        authorization_code = credentials.get("code")
        if not authorization_code:
            return None
        
        try:
            config = await self._get_oidc_config()
            
            # OAuth2クライアントを作成
            client = AsyncOAuth2Client(
                client_id=self.client_id,
                client_secret=self.client_secret
            )
            
            # 認証コードをトークンに交換
            token = await client.fetch_token(
                config["token_endpoint"],
                authorization_response=credentials.get("authorization_response"),
                redirect_uri=self.redirect_uri
            )
            
            # IDトークンを検証
            id_token = token.get("id_token")
            if id_token:
                jwks = await self._get_jwks()
                claims = CodeIDToken().decode(
                    id_token,
                    jwks,
                    claims_options={"iss": {"essential": True, "value": config["issuer"]}}
                )
                
                # ユーザー情報を抽出
                user_info = {
                    "email": claims.get("email"),
                    "name": claims.get("name"),
                    "sub": claims.get("sub"),
                    "groups": claims.get("groups", [])
                }
                
                return user_info
            
            return None
            
        except Exception as e:
            logger.error("OIDC authentication failed", error=str(e))
            return None
    
    def get_login_url(self, redirect_uri: str) -> str:
        """OIDC認証URLを生成"""
        params = {
            "client_id": self.client_id,
            "redirect_uri": redirect_uri,
            "response_type": "code",
            "scope": "openid profile email",
            "state": "random_state_value"  # 実際にはランダムな値を生成
        }
        
        query_string = "&".join([f"{k}={v}" for k, v in params.items()])
        return f"{self.oidc_config['authorization_endpoint']}?{query_string}"
    
    async def get_user_info(self, access_token: str) -> Optional[Dict[str, Any]]:
        """アクセストークンからユーザー情報を取得"""
        try:
            config = await self._get_oidc_config()
            
            async with httpx.AsyncClient() as client:
                response = await client.get(
                    config["userinfo_endpoint"],
                    headers={"Authorization": f"Bearer {access_token}"}
                )
                response.raise_for_status()
                return response.json()
                
        except Exception as e:
            logger.error("Failed to get user info", error=str(e))
            return None
```

### 2. OIDCエンドポイント

```python
# libkoiki/api/v1/endpoints/auth_oidc.py
from fastapi import APIRouter, Request, HTTPException, Depends, Query
from fastapi.responses import RedirectResponse
from sqlalchemy.ext.asyncio import AsyncSession
from typing import Optional
import structlog

from libkoiki.core.auth_providers import AuthProvider
from libkoiki.services.sso_auth_service import SSOAuthService
from libkoiki.core.security import create_access_token
from libkoiki.db.session import get_db
from libkoiki.api.dependencies import get_sso_auth_service

logger = structlog.get_logger(__name__)
router = APIRouter()

@router.get("/oidc/login")
async def oidc_login(
    request: Request,
    sso_service: SSOAuthService = Depends(get_sso_auth_service)
):
    """OpenID Connect認証開始"""
    try:
        oidc_provider = sso_service.auth_providers.get(AuthProvider.OIDC)
        if not oidc_provider:
            raise HTTPException(status_code=500, detail="OIDC provider not configured")
        
        # OIDC認証URLを生成
        login_url = oidc_provider.get_login_url(
            redirect_uri=str(request.url_for("oidc_callback"))
        )
        
        return RedirectResponse(url=login_url)
        
    except Exception as e:
        logger.error("OIDC login initiation failed", error=str(e))
        raise HTTPException(status_code=500, detail="OIDC login failed")

@router.get("/oidc/callback")
async def oidc_callback(
    request: Request,
    code: str = Query(...),
    state: Optional[str] = Query(None),
    db: AsyncSession = Depends(get_db),
    sso_service: SSOAuthService = Depends(get_sso_auth_service)
):
    """OpenID Connect認証コールバック"""
    try:
        # OIDC認証実行
        user, message = await sso_service.authenticate_sso(
            provider=AuthProvider.OIDC,
            credentials={
                "code": code,
                "state": state,
                "authorization_response": str(request.url)
            },
            db=db
        )
        
        if not user:
            logger.warning("OIDC authentication failed", message=message)
            raise HTTPException(status_code=401, detail="Authentication failed")
        
        # JWTトークンを生成
        access_token = create_access_token(
            data={"sub": str(user.id), "email": user.email}
        )
        
        # フロントエンドにリダイレクト
        frontend_url = f"{settings.FRONTEND_URL}/auth/callback?token={access_token}"
        return RedirectResponse(url=frontend_url)
        
    except Exception as e:
        logger.error("OIDC callback processing failed", error=str(e))
        raise HTTPException(status_code=500, detail="Authentication processing failed")
```

## 設定とデプロイ

### 1. 設定ファイルの拡張

```python
# libkoiki/core/config.py
class Settings(BaseSettings):
    # ... 既存設定 ...
    
    # SAML設定
    SAML_ENABLED: bool = False
    SAML_SP_ENTITY_ID: str = ""
    SAML_SP_CERT: str = ""
    SAML_SP_PRIVATE_KEY: str = ""
    SAML_IDP_ENTITY_ID: str = ""
    SAML_IDP_SSO_URL: str = ""
    SAML_IDP_SLO_URL: str = ""
    SAML_IDP_CERT: str = ""
    
    # OpenID Connect設定
    OIDC_ENABLED: bool = False
    OIDC_CLIENT_ID: str = ""
    OIDC_CLIENT_SECRET: str = ""
    OIDC_DISCOVERY_URL: str = ""
    
    # OAuth2設定（Google, Microsoft等）
    OAUTH2_PROVIDERS: Dict[str, Dict[str, str]] = {}
    
    # フロントエンド設定
    FRONTEND_URL: str = "http://localhost:3000"
    BASE_URL: str = "http://localhost:8000"
```

### 2. 依存関係の追加

```bash
# requirements.txt に追加
python3-saml==1.14.0
authlib==1.2.1
httpx==0.24.1
```

### 3. データベースモデルの拡張

```python
# libkoiki/models/user.py
class UserModel(Base):
    __tablename__ = "users"
    
    # ... 既存フィールド ...
    
    # SSO関連フィールド
    auth_provider: Optional[str] = Column(String(50), default="local")
    external_user_id: Optional[str] = Column(String(255))
    sso_attributes: Optional[Dict[str, Any]] = Column(JSON)
    
    # インデックス
    __table_args__ = (
        Index("idx_users_external_user_id", "external_user_id"),
        Index("idx_users_auth_provider", "auth_provider"),
    )
```

## フロントエンド対応

### 1. React実装例

```typescript
// services/ssoAuthService.ts
export class SSOAuthService {
  private baseURL = '/api/v1/auth';
  
  // SAML認証開始
  async loginWithSAML(): Promise<void> {
    window.location.href = `${this.baseURL}/saml/login`;
  }
  
  // OpenID Connect認証開始
  async loginWithOIDC(): Promise<void> {
    window.location.href = `${this.baseURL}/oidc/login`;
  }
  
  // 認証コールバック処理
  async handleAuthCallback(token: string): Promise<void> {
    // JWTトークンを保存
    localStorage.setItem('access_token', token);
    
    // ユーザー情報を取得
    const userInfo = await this.getUserInfo(token);
    
    // 状態管理にユーザー情報を保存
    // Redux、Zustand等を使用
  }
  
  // 従来のログイン（併用）
  async loginWithPassword(email: string, password: string): Promise<TokenResponse> {
    // 既存のパスワード認証
    return this.authService.login({ username: email, password });
  }
}

// components/LoginComponent.tsx
export const LoginComponent: React.FC = () => {
  const [authMethod, setAuthMethod] = useState<'password' | 'sso'>('password');
  const ssoService = new SSOAuthService();
  
  const handleSSOLogin = async (provider: 'saml' | 'oidc') => {
    try {
      if (provider === 'saml') {
        await ssoService.loginWithSAML();
      } else {
        await ssoService.loginWithOIDC();
      }
    } catch (error) {
      console.error('SSO login failed:', error);
    }
  };
  
  return (
    <div className="login-container">
      <div className="auth-method-selector">
        <button 
          onClick={() => setAuthMethod('password')}
          className={authMethod === 'password' ? 'active' : ''}
        >
          パスワード認証
        </button>
        <button 
          onClick={() => setAuthMethod('sso')}
          className={authMethod === 'sso' ? 'active' : ''}
        >
          SSO認証
        </button>
      </div>
      
      {authMethod === 'password' && (
        <PasswordLoginForm />
      )}
      
      {authMethod === 'sso' && (
        <div className="sso-login-options">
          <button 
            onClick={() => handleSSOLogin('saml')}
            className="sso-button saml-button"
          >
            SAML認証でログイン
          </button>
          <button 
            onClick={() => handleSSOLogin('oidc')}
            className="sso-button oidc-button"
          >
            OpenID Connect認証でログイン
          </button>
        </div>
      )}
    </div>
  );
};
```

## 運用上の考慮点

### 1. セキュリティ
- 証明書の適切な管理
- HTTPS必須
- CSRFトークンの実装
- セッション管理の強化

### 2. パフォーマンス
- 外部認証サービスの応答時間
- キャッシュ戦略
- 負荷分散

### 3. 可用性
- 外部サービス障害時のフォールバック
- 複数認証方式の併用
- 監視とアラート

KOIKI-FWは柔軟な設計により、既存のJWT認証を活かしながらSSO連携を実現できます。段階的な導入も可能で、運用要件に応じてカスタマイズできます。

---

_**User**_

SSO連携のために、ソース変更する箇所はありますか？

---

_**Assistant**_

はい、SSO連携のためにKOIKI-FWの既存ソースを変更する必要があります。主な変更箇所と詳細をご説明します。

## 主な変更箇所

### 1. データベースモデルの拡張

````python
# libkoiki/models/user.py
from sqlalchemy import Column, Integer, String, Boolean, DateTime, JSON, Index
from sqlalchemy.sql import func
from typing import Optional, Dict, Any

# 既存のUserModelに以下のフィールドを追加
class UserModel(Base):
    __tablename__ = "users"
    
    # ...existing code...
    
    # SSO関連フィールドを追加
    auth_provider: Optional[str] = Column(String(50), default="local", nullable=True)
    external_user_id: Optional[str] = Column(String(255), nullable=True)
    sso_attributes: Optional[Dict[str, Any]] = Column(JSON, nullable=True)
    
    # インデックスを追加
    __table_args__ = (
        Index("idx_users_external_user_id", "external_user_id"),
        Index("idx_users_auth_provider", "auth_provider"),
        Index("idx_users_email", "email"),  # 既存の場合は不要
    )
````

### 2. Alembicマイグレーション

````python
# alembic/versions/xxx_add_sso_fields.py
"""Add SSO fields to users table

Revision ID: xxx
Revises: previous_revision
Create Date: 2025-07-08 12:00:00.000000

"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers
revision = 'xxx'
down_revision = 'previous_revision'
branch_labels = None
depends_on = None

def upgrade():
    # SSO関連フィールドを追加
    op.add_column('users', sa.Column('auth_provider', sa.String(50), nullable=True, default='local'))
    op.add_column('users', sa.Column('external_user_id', sa.String(255), nullable=True))
    op.add_column('users', sa.Column('sso_attributes', postgresql.JSON(astext_type=sa.Text()), nullable=True))
    
    # インデックスを追加
    op.create_index('idx_users_external_user_id', 'users', ['external_user_id'])
    op.create_index('idx_users_auth_provider', 'users', ['auth_provider'])
    
    # 既存ユーザーのauth_providerを'local'に設定
    op.execute("UPDATE users SET auth_provider = 'local' WHERE auth_provider IS NULL")

def downgrade():
    # インデックスを削除
    op.drop_index('idx_users_auth_provider', table_name='users')
    op.drop_index('idx_users_external_user_id', table_name='users')
    
    # カラムを削除
    op.drop_column('users', 'sso_attributes')
    op.drop_column('users', 'external_user_id')
    op.drop_column('users', 'auth_provider')
````

### 3. Pydanticスキーマの拡張

````python
# libkoiki/schemas/user.py
from pydantic import BaseModel, Field
from typing import Optional, Dict, Any
from datetime import datetime

# 既存のスキーマを拡張
class UserBase(BaseModel):
    email: str = Field(..., description="メールアドレス")
    full_name: Optional[str] = Field(None, description="フルネーム")
    is_active: bool = Field(True, description="アクティブ状態")
    # SSO関連フィールドを追加
    auth_provider: Optional[str] = Field("local", description="認証プロバイダー")
    external_user_id: Optional[str] = Field(None, description="外部ユーザーID")

class UserCreate(UserBase):
    password: str = Field(..., min_length=8, description="パスワード")
    
    # SSO用のバリデーション
    @validator('password')
    def validate_password_for_sso(cls, v, values):
        # SSO認証の場合はパスワードを空文字にする
        if values.get('auth_provider') and values.get('auth_provider') != 'local':
            return ""  # SSO認証なのでパスワードは不要
        return v

class UserResponse(UserBase):
    id: int
    created_at: datetime
    updated_at: datetime
    
    class Config:
        from_attributes = True

# SSO専用スキーマを追加
class UserSSO(BaseModel):
    email: str
    full_name: Optional[str] = None
    auth_provider: str
    external_user_id: str
    sso_attributes: Optional[Dict[str, Any]] = None
    
    class Config:
        from_attributes = True
````

### 4. UserServiceの拡張

````python
# libkoiki/services/user_service.py
from typing import Optional, Dict, Any
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select

# 既存のUserServiceに以下のメソッドを追加
class UserService:
    # ...existing code...
    
    async def get_user_by_external_id(
        self, 
        external_user_id: str, 
        auth_provider: str, 
        db: AsyncSession
    ) -> Optional[UserModel]:
        """外部ユーザーIDと認証プロバイダーでユーザーを取得"""
        query = select(UserModel).where(
            UserModel.external_user_id == external_user_id,
            UserModel.auth_provider == auth_provider
        )
        result = await db.execute(query)
        return result.scalars().first()
    
    async def create_sso_user(
        self, 
        user_data: UserSSO, 
        db: AsyncSession
    ) -> UserModel:
        """SSO認証用ユーザーを作成"""
        user = UserModel(
            email=user_data.email,
            full_name=user_data.full_name,
            hashed_password="",  # SSO認証なのでパスワードは空
            auth_provider=user_data.auth_provider,
            external_user_id=user_data.external_user_id,
            sso_attributes=user_data.sso_attributes,
            is_active=True
        )
        
        db.add(user)
        await db.commit()
        await db.refresh(user)
        
        return user
    
    async def update_sso_user(
        self, 
        user: UserModel, 
        sso_data: Dict[str, Any], 
        db: AsyncSession
    ) -> UserModel:
        """SSO認証情報でユーザーを更新"""
        if sso_data.get("name") and sso_data["name"] != user.full_name:
            user.full_name = sso_data["name"]
        
        # SSO属性を更新
        user.sso_attributes = sso_data
        
        db.add(user)
        await db.commit()
        await db.refresh(user)
        
        return user
````

### 5. 設定ファイルの拡張

````python
# libkoiki/core/config.py
from pydantic import BaseSettings
from typing import Dict, Any, Optional

class Settings(BaseSettings):
    # ...existing code...
    
    # SSO全般設定
    SSO_ENABLED: bool = False
    FRONTEND_URL: str = "http://localhost:3000"
    BASE_URL: str = "http://localhost:8000"
    
    # SAML設定
    SAML_ENABLED: bool = False
    SAML_SP_ENTITY_ID: Optional[str] = None
    SAML_SP_CERT: Optional[str] = None
    SAML_SP_PRIVATE_KEY: Optional[str] = None
    SAML_IDP_ENTITY_ID: Optional[str] = None
    SAML_IDP_SSO_URL: Optional[str] = None
    SAML_IDP_SLO_URL: Optional[str] = None
    SAML_IDP_CERT: Optional[str] = None
    
    # OpenID Connect設定
    OIDC_ENABLED: bool = False
    OIDC_CLIENT_ID: Optional[str] = None
    OIDC_CLIENT_SECRET: Optional[str] = None
    OIDC_DISCOVERY_URL: Optional[str] = None
    
    # OAuth2設定（Google, Microsoft等）
    OAUTH2_PROVIDERS: Dict[str, Dict[str, str]] = {}
    
    class Config:
        env_file = ".env"
        case_sensitive = True
````

### 6. APIルーターの拡張

````python
# libkoiki/api/v1/api.py
from fastapi import APIRouter
from libkoiki.api.v1.endpoints import (
    auth_basic,
    auth_password,
    auth_token,
    # SSO関連エンドポイントを追加
    auth_saml,
    auth_oidc,
    # ...existing imports...
)

api_router = APIRouter()

# 既存のルーターを含める
api_router.include_router(auth_basic.router, prefix="/auth", tags=["authentication"])
api_router.include_router(auth_password.router, prefix="/auth", tags=["authentication"])
api_router.include_router(auth_token.router, prefix="/auth", tags=["authentication"])

# SSO関連ルーターを追加
api_router.include_router(auth_saml.router, prefix="/auth", tags=["sso"])
api_router.include_router(auth_oidc.router, prefix="/auth", tags=["sso"])
````

### 7. 依存関係の追加

````python
# libkoiki/api/dependencies.py
from fastapi import Depends
from sqlalchemy.ext.asyncio import AsyncSession
from libkoiki.services.sso_auth_service import SSOAuthService
from libkoiki.services.user_service import UserService
from libkoiki.core.auth_providers import AuthProvider
from libkoiki.core.auth_providers.saml_provider import SAMLAuthProvider
from libkoiki.core.auth_providers.oidc_provider import OIDCAuthProvider
from libkoiki.core.config import settings

# 既存のDependenciesに追加
def get_sso_auth_service(
    user_service: UserService = Depends(get_user_service),
) -> SSOAuthService:
    """SSO認証サービスの依存関係"""
    auth_providers = {}
    
    # 有効なプロバイダーを初期化
    if settings.SAML_ENABLED:
        auth_providers[AuthProvider.SAML] = SAMLAuthProvider()
    
    if settings.OIDC_ENABLED:
        auth_providers[AuthProvider.OIDC] = OIDCAuthProvider()
    
    return SSOAuthService(user_service, auth_providers)
````

### 8. 既存認証ミドルウェアの調整

````python
# libkoiki/core/security.py
from typing import Optional
from fastapi import HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from jose import JWTError, jwt
from sqlalchemy.ext.asyncio import AsyncSession

# 既存のverify_tokenを拡張
async def verify_token(token: str, db: AsyncSession) -> Optional[UserModel]:
    """トークンを検証してユーザーを取得（SSO対応）"""
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=["HS256"])
        user_id: str = payload.get("sub")
        if user_id is None:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid authentication credentials"
            )
        
        # ユーザーを取得（SSO認証ユーザーも含む）
        user = await get_user_by_id(int(user_id), db)
        if user is None:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="User not found"
            )
        
        # SSO認証ユーザーの場合は追加チェック
        if user.auth_provider and user.auth_provider != "local":
            # SSO認証ユーザーの特別な処理があれば実装
            pass
        
        return user
        
    except JWTError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid authentication credentials"
        )
````

### 9. 環境変数の設定

````bash
# .env.example に追加
# SSO設定
SSO_ENABLED=true
FRONTEND_URL=http://localhost:3000
BASE_URL=http://localhost:8000

# SAML設定
SAML_ENABLED=true
SAML_SP_ENTITY_ID=https://yourapp.com
SAML_SP_CERT=-----BEGIN CERTIFICATE-----...-----END CERTIFICATE-----
SAML_SP_PRIVATE_KEY=-----BEGIN PRIVATE KEY-----...-----END PRIVATE KEY-----
SAML_IDP_ENTITY_ID=https://sso.company.com
SAML_IDP_SSO_URL=https://sso.company.com/sso
SAML_IDP_SLO_URL=https://sso.company.com/slo
SAML_IDP_CERT=-----BEGIN CERTIFICATE-----...-----END CERTIFICATE-----

# OpenID Connect設定
OIDC_ENABLED=true
OIDC_CLIENT_ID=your-client-id
OIDC_CLIENT_SECRET=your-client-secret
OIDC_DISCOVERY_URL=https://sso.company.com/.well-known/openid-configuration
````

### 10. 新しい依存関係の追加

````toml
# pyproject.toml に追加
[tool.poetry.dependencies]
# ...existing dependencies...
python3-saml = "^1.14.0"
authlib = "^1.2.1"
httpx = "^0.24.1"
````

## 実装手順

### 1. 段階的な実装

```bash
# 1. データベースマイグレーション
alembic revision --autogenerate -m "Add SSO fields to users table"
alembic upgrade head

# 2. 依存関係のインストール
poetry install
# または
pip install python3-saml==1.14.0 authlib==1.2.1 httpx==0.24.1

# 3. 環境変数の設定
cp .env.example .env
# .envファイルを編集してSSO設定を追加

# 4. 新しいファイルの作成
mkdir -p libkoiki/core/auth_providers
mkdir -p libkoiki/api/v1/endpoints/auth_saml
mkdir -p libkoiki/api/v1/endpoints/auth_oidc
```

### 2. 既存機能への影響の最小化

````python
# libkoiki/services/user_service.py
# 既存のメソッドを拡張（破壊的変更を避ける）
async def create_user(self, user_create: UserCreate, db: AsyncSession) -> UserModel:
    # ...existing code...
    
    # SSO関連フィールドの処理を追加
    hashed_password = get_password_hash(user_create.password) if user_create.password else ""
    
    user = UserModel(
        email=user_create.email,
        full_name=user_create.full_name,
        hashed_password=hashed_password,
        is_active=user_create.is_active,
        # SSO関連フィールドを追加
        auth_provider=getattr(user_create, 'auth_provider', 'local'),
        external_user_id=getattr(user_create, 'external_user_id', None),
    )
    
    # ...existing code...
````

### 3. 後方互換性の維持

````python
# libkoiki/models/user.py
# 既存のUserModelに追加するフィールドはすべてOptionalにする
class UserModel(Base):
    # ...existing code...
    
    # デフォルト値を設定して既存データとの互換性を保つ
    auth_provider: Optional[str] = Column(String(50), default="local", nullable=True)
    external_user_id: Optional[str] = Column(String(255), nullable=True)
    sso_attributes: Optional[Dict[str, Any]] = Column(JSON, nullable=True)
````

## テストの更新

````python
# tests/test_auth_sso.py
import pytest
from httpx import AsyncClient
from sqlalchemy.ext.asyncio import AsyncSession

from libkoiki.core.auth_providers import AuthProvider
from libkoiki.services.sso_auth_service import SSOAuthService
from libkoiki.models.user import UserModel

@pytest.mark.asyncio
async def test_sso_user_creation(db_session: AsyncSession):
    """SSO認証でのユーザー作成をテスト"""
    # テスト実装
    pass

@pytest.mark.asyncio
async def test_saml_authentication(client: AsyncClient):
    """SAML認証フローをテスト"""
    # テスト実装
    pass

@pytest.mark.asyncio
async def test_oidc_authentication(client: AsyncClient):
    """OpenID Connect認証フローをテスト"""
    # テスト実装
    pass
````

## 主な変更点まとめ

1. **データベーススキーマ**: SSO関連フィールドの追加
2. **Pydanticスキーマ**: SSO対応のバリデーション追加
3. **UserService**: SSO認証用メソッドの追加
4. **設定ファイル**: SSO設定項目の追加
5. **APIルーター**: SSO認証エンドポイントの追加
6. **依存関係**: 新しいライブラリの追加
7. **環境変数**: SSO設定の追加

これらの変更により、既存のJWT認証システムを維持しながら、SSO認証を追加できます。段階的な実装により、既存機能への影響を最小限に抑えることができます。

---

