<!-- Generated by SpecStory -->

# 認証APIを整備しましたが、このプログラムは、外部のSSOサービス連携で動作することになりそうです。 (2025-07-11 15:38Z)

_**User**_

認証APIを整備しましたが、このプログラムは、外部のSSOサービス連携で動作することになりそうです。ユーザー管理は、SSOサービス先のディレクトリーサービスが担当するので、その場合のこのシステムのためのトークン発行するAPIを提案してください。まだソース作成、変更は必要ありません。

---

_**Assistant**_

現在の認証APIの構成を確認して、外部SSOサービス連携を考慮したトークン発行APIの提案をさせていただきます。まず、現在の認証システムの状況を把握させてください。 現在の認証システムの構成を確認しました。外部SSOサービス連携を前提とした場合のトークン発行APIの提案をさせていただきます。

## 外部SSO連携向けトークン発行API提案

### 背景と考慮事項

現在のKOIKI-FWは以下の認証システムを持っています：
- JWT ベースの認証（アクセストークン + リフレッシュトークン）
- 独自ユーザー管理（登録、パスワード管理）
- ログイン試行制限、セキュリティ機能

外部SSOサービス連携では：
- **ユーザー管理**: SSOプロバイダーのディレクトリーサービスが担当
- **認証**: SSOプロバイダーが実行
- **トークン発行**: KOIKI-FWがアプリケーション専用トークンを発行

### 提案API設計

#### 1. **SSO認証後のトークン発行API**

```http
POST /auth/sso/token-exchange
```

**用途**: SSOプロバイダーから受け取ったトークン（ID Token、Authorization Code等）を、KOIKI-FW内部で使用するJWTアクセストークンに交換

**リクエスト例**:
```json
{
  "provider": "microsoft",  // "microsoft", "google", "okta", "saml" など
  "token_type": "id_token", // "id_token", "authorization_code", "access_token"
  "token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsIng1dCI...",
  "client_info": {
    "device_info": "Mozilla/5.0...",
    "ip_address": "192.168.1.100"
  }
}
```

**レスポンス例**:
```json
{
  "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "refresh_token": "def50200b8a1c3d4e5f6...",
  "token_type": "bearer",
  "expires_in": 3600,
  "user": {
    "id": "sso_user_id_12345",
    "email": "user@company.com",
    "full_name": "山田 太郎",
    "department": "開発部",
    "roles": ["user", "developer"]
  }
}
```

#### 2. **SSO認証検証API**

```http
POST /auth/sso/verify
```

**用途**: SSOプロバイダーのトークンを検証し、ユーザー情報を取得（トークン発行なし）

**リクエスト例**:
```json
{
  "provider": "microsoft",
  "token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIs..."
}
```

**レスポンス例**:
```json
{
  "valid": true,
  "user": {
    "sso_id": "user@company.com",
    "email": "user@company.com",
    "full_name": "山田 太郎",
    "department": "開発部",
    "groups": ["developers", "managers"]
  },
  "expires_at": "2025-07-12T18:00:00Z"
}
```

#### 3. **SSO無効化API**

```http
POST /auth/sso/logout
```

**用途**: SSO連携セッションの終了とKOIKI-FWトークンの無効化

**リクエスト例**:
```json
{
  "provider": "microsoft",
  "sso_logout_url": "https://login.microsoftonline.com/logout",
  "post_logout_redirect_uri": "https://your-app.com/logout-complete"
}
```

#### 4. **SSO設定情報取得API**

```http
GET /auth/sso/config/{provider}
```

**用途**: フロントエンド向けのSSO設定情報提供

**レスポンス例**:
```json
{
  "provider": "microsoft",
  "authorization_url": "https://login.microsoftonline.com/common/oauth2/v2.0/authorize",
  "client_id": "your-client-id",
  "redirect_uri": "https://your-app.com/auth/callback",
  "scopes": ["openid", "profile", "email"],
  "discovery_url": "https://login.microsoftonline.com/common/v2.0/.well-known/openid_configuration"
}
```

### セキュリティ機能

#### **1. トークン検証**
- SSOプロバイダーの公開鍵による署名検証
- トークンの有効期限チェック
- Audience（対象アプリケーション）の検証
- Issuer（発行者）の検証

#### **2. ユーザー情報同期**
- SSOプロバイダーからの属性マッピング
- 部署・ロール情報の自動同期
- ローカルキャッシュによる性能向上

#### **3. セッション管理**
- SSOセッションとローカルセッションの連携
- Single Logout（SLO）対応
- セッション期限の同期

### 実装時の考慮事項

#### **1. プロバイダー対応**
- Microsoft Azure AD / Entra ID
- Google Workspace
- Okta
- SAML 2.0 汎用プロバイダー
- OpenID Connect汎用プロバイダー

#### **2. フォールバック機能**
- SSOサービス障害時のローカル認証
- 管理者アカウントによる緊急アクセス
- オフライン時の認証処理

#### **3. 監査・コンプライアンス**
- SSO認証ログの記録
- アクセス履歴の追跡
- セキュリティイベントの監視

### 既存システムとの統合

#### **既存機能の活用**
- JWTトークンシステムの継続利用
- リフレッシュトークン機能の維持
- ログイン試行制限の適用（SSO側の制限と連携）
- 監査ログシステムの拡張

#### **新規追加が必要な機能**
- SSOプロバイダー設定管理
- トークン変換・マッピング機能
- ユーザー属性同期機能
- SSO専用のミドルウェア

この設計により、既存の認証システムを活かしながら、外部SSOサービスとのシームレスな連携が実現できます。段階的な導入も可能で、従来のパスワード認証とSSO認証を併用することもできます。

---

_**User**_

外部SSOサービスは、SAML,OIDC それぞれ以下の内容となっています。このプロジェクトですと、どちらの方式を採用すべきでしょうか？
==
シングル サインオン

HENNGE Access Control (SAML 認証)
SAML2.0 に対応している
SAML認証の NameID (ユーザーアカウント情報) が HENNGE Access Control 上のユーザー情報のいずれかの項目に一致している
SP-Initiated SSO / IdP-Initiated SSOの両方、またはいずれかに対応している
NameIDFormat として「 urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress 」又は、「 urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified 」を扱える
SHA-256（SHA-2）の SAML 署名証明書に対応している

HENNGE Access Control (OpenID Connect)
Authorization Code Flow に対応した Relying Party (証明書利用者信頼) である
Confidential client (機密クライアント) である
クライアント認証が client_secret_post, client_secret_basic のいずれかである
スコープが openid, profile, email, offline_access のいずれかである
ID token のクレームには aud, iss, sub, iat, exp, hd, name, given_name, family_name, preferred_username, email, email_verified, zoneinfo, locale, updated_at, auth_time, nonce, custom attributes が使用可能
リダイレクト URI が HTTPS 形式の URL、もしくは localhost (127.0.0.1、[::1] を含む) である

---

_**Assistant**_

HENNGE Access Controlとの連携において、KOIKI-FWの現在の設計とアーキテクチャを考慮すると、**OpenID Connect (OIDC)** を採用することを強く推奨します。

## 推奨理由の詳細分析

### 1. **技術的適合性**

#### **OpenID Connect の優位性**
- **JWT ベース**: KOIKI-FWは既にJWT認証システムを持っており、OIDCのID TokenもJWT形式なので親和性が高い
- **RESTful API**: 現在のFastAPI設計にシームレスに統合可能
- **標準化されたクレーム**: `sub`, `email`, `name`, `given_name`, `family_name`等の標準クレームが利用可能

#### **SAML の課題**
- **XML ベース**: 現在のJSON/JWT中心の設計との整合性が低い
- **複雑な実装**: SAML assertion の解析、署名検証が複雑
- **ステートフル**: セッション管理が必要で、現在のステートレス設計と矛盾

### 2. **KOIKI-FWへの統合容易性** 現在のセキュリティシステムを確認すると、既にJWT中心の設計になっており、OIDCとの親和性が非常に高いことがわかります。

#### **OpenID Connect 統合の優位性**

```python
# 既存のJWTトークン検証ロジックを拡張可能
async def verify_oidc_token(id_token: str, provider: str) -> dict:
    """OIDC ID Tokenを検証してクレームを取得"""
    # 既存のJWT検証ロジックと類似の実装が可能
    # HENNGE Access ControlのJWKS Endpointから公開鍵を取得
    # 署名検証、期限チェック等
```

### 3. **開発効率と保守性**

#### **OpenID Connect**
- **ライブラリサポート**: Python の `authlib`, `python-jose` 等で十分なサポート
- **デバッグ容易**: JWT形式なので、jwt.ioでデコード可能
- **ログ対応**: 既存の構造化ログに統合しやすい

#### **SAML**
- **専用ライブラリ必要**: `python-saml` 等の専門ライブラリが必要
- **XML解析**: 複雑なXML処理とnamespace管理
- **デバッグ困難**: バイナリ署名等でトラブルシューティングが複雑

### 4. **HENNGE Access Control の機能活用**

#### **OIDC で利用可能なクレーム**
```json
{
  "sub": "user_unique_id",
  "email": "user@company.com",
  "name": "山田 太郎",
  "given_name": "太郎",
  "family_name": "山田",
  "preferred_username": "yamada.taro",
  "email_verified": true,
  "custom_attributes": {
    "department": "開発部",
    "employee_id": "E12345"
  }
}
```

これらの情報を直接KOIKI-FWのユーザーモデルにマッピング可能です。

### 5. **実装提案**

#### **新しいエンドポイント設計**

```python
# libkoiki/api/v1/endpoints/auth_oidc.py (新規作成)
@router.post("/oidc/callback")
async def oidc_callback(
    authorization_code: str,
    state: str,
    db: AsyncSession = Depends(get_db)
):
    """HENNGE Access Control からのコールバック処理"""
    # 1. authorization_code を access_token に交換
    # 2. ID Token を取得・検証
    # 3. ユーザー情報を同期
    # 4. KOIKI-FW内部用のJWTトークンを発行
```

#### **統合ルーターへの追加**

```python
# libkoiki/api/v1/endpoints/auth.py に追加
from . import auth_oidc

# OIDC認証機能
router.include_router(auth_oidc.router, tags=["Authentication - OIDC"])
```

### 6. **セキュリティ考慮事項**

#### **OpenID Connect の優位性**
- **標準仕様**: OAuth 2.0 + OpenID Connect の標準的なセキュリティ
- **PKCE対応**: Authorization Code Flow + PKCE で追加のセキュリティ
- **Nonce検証**: リプレイアタック対策

#### **実装時のセキュリティポイント**
- **state パラメーター**: CSRF攻撃対策
- **JWKSローテーション**: 定期的な公開鍵の更新対応
- **トークン検証**: `aud`, `iss`, `exp` の厳密な検証

## 結論

**OpenID Connect (OIDC)** を採用することを強く推奨します。理由は：

1. **既存システムとの親和性**: JWT ベースの現在の認証システムとシームレスに統合
2. **開発効率**: FastAPI エコシステムとの相性が良い
3. **保守性**: JSON ベースで理解しやすく、デバッグが容易
4. **拡張性**: 将来的な他のOIDCプロバイダーとの連携も容易
5. **セキュリティ**: 現代的な標準仕様に準拠

SAMLは確かに企業環境では広く使われていますが、KOIKI-FWのモダンなアーキテクチャには OpenID Connect の方が適しています。

---

_**User**_

OpenID Connect (OIDC) を採用することとします。新しいエンドポイント設計 @router.post("/oidc/callback") の提案もありますが、ここまでの情報全体から、新たに設計すべき最小限のSSO連携に必要なAPI群を、一覧整理し提案してください。

---

_**Assistant**_

HENNGE Access Control (OIDC) との連携において、最小限のSSO連携に必要なAPI群を整理して提案いたします。

## 最小限のSSO連携API設計

### 1. **フロントエンド向け認証開始API**

```http
GET /auth/oidc/auth-url
```

**用途**: フロントエンドがOIDC認証を開始するためのリダイレクトURL生成

**レスポンス例**:
```json
{
  "auth_url": "https://hennge.com/oauth2/authorize?client_id=...&redirect_uri=...&state=...&nonce=...",
  "state": "generated_state_value"
}
```

### 2. **OIDC認証コールバックAPI**

```http
POST /auth/oidc/callback
```

**用途**: HENNGE Access Controlからの認証結果を受け取り、内部JWTトークンを発行

**リクエスト例**:
```json
{
  "code": "authorization_code_from_hennge",
  "state": "state_value_sent_to_hennge"
}
```

**レスポンス例**:
```json
{
  "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "refresh_token": "def50200b8a1c3d4e5f6...",
  "token_type": "bearer",
  "expires_in": 3600,
  "user": {
    "id": "oidc_sub_value",
    "email": "user@company.com",
    "full_name": "山田 太郎",
    "is_active": true
  }
}
```

### 3. **OIDC設定情報取得API**

```http
GET /auth/oidc/config
```

**用途**: フロントエンド向けのOIDC設定情報提供

**レスポンス例**:
```json
{
  "client_id": "your_client_id",
  "authorization_endpoint": "https://hennge.com/oauth2/authorize",
  "redirect_uri": "https://your-app.com/auth/callback",
  "scopes": ["openid", "profile", "email"],
  "response_type": "code"
}
```

### 4. **SSOログアウトAPI**

```http
POST /auth/oidc/logout
```

**用途**: ローカルセッション終了とHENNGE Access Controlへのログアウト連携

**リクエスト例**:
```json
{
  "id_token_hint": "original_id_token_from_hennge"
}
```

**レスポンス例**:
```json
{
  "logout_url": "https://hennge.com/oauth2/logout?id_token_hint=...&post_logout_redirect_uri=...",
  "message": "Local session terminated"
}
```

## ファイル構成提案

### 1. **新規ファイル作成**

```
libkoiki/api/v1/endpoints/auth_oidc.py  # OIDCエンドポイント
libkoiki/services/oidc_service.py       # OIDC認証ロジック
libkoiki/schemas/oidc.py               # OIDCリクエスト/レスポンススキーマ
```

### 2. **設定ファイル拡張**

```python
# libkoiki/core/config.py に追加
class Settings(BaseSettings):
    # 既存設定...
    
    # OIDC設定
    OIDC_CLIENT_ID: str = ""
    OIDC_CLIENT_SECRET: str = ""
    OIDC_ISSUER: str = "https://hennge.com"
    OIDC_REDIRECT_URI: str = "https://your-app.com/auth/callback"
    OIDC_SCOPES: str = "openid profile email"
```

### 3. **認証ルーター統合**

現在の `auth.py` に追加:

```python
# 既存のインポートに追加
from . import auth_oidc

# 既存のルーター追加の後に
# OIDC認証機能
router.include_router(auth_oidc.router, tags=["Authentication - OIDC"])
```

## 最小限の実装範囲

### **必須実装項目**

1. **OIDC Authorization Code Flow**
   - 認証URL生成
   - コールバック処理
   - ID Token検証

2. **ユーザー情報同期**
   - HENNGEからのクレーム取得
   - ローカルユーザーデータ作成/更新
   - 属性マッピング（email, name等）

3. **内部JWT発行**
   - 既存のJWTシステム活用
   - OIDC認証済みユーザー向けトークン生成

4. **状態管理**
   - state/nonce検証によるセキュリティ確保

### **段階的実装が可能な項目**

1. **高度なログアウト**
   - Single Logout (SLO)
   - セッション管理の高度化

2. **追加セキュリティ**
   - PKCE (Proof Key for Code Exchange)
   - JWTのより厳密な検証

3. **運用機能**
   - OIDC認証の監査ログ
   - エラーハンドリングの詳細化

## 技術的考慮事項

### **セキュリティ**
- **state検証**: CSRF攻撃防止
- **nonce検証**: リプレイアタック防止  
- **ID Token検証**: 署名、issuer、audience、有効期限の検証
- **HTTPS必須**: 本番環境での通信暗号化

### **パフォーマンス**
- **JWKSキャッシュ**: HENNGE Access Controlの公開鍵キャッシュ
- **セッション最適化**: 不要なデータベースアクセス削減

### **可用性**
- **フォールバック認証**: OIDC障害時のローカル認証継続
- **エラーハンドリング**: ユーザーフレンドリーなエラーメッセージ

## 実装優先順位

### **Phase 1: 基本OIDC連携**
1. `/auth/oidc/auth-url` - 認証開始
2. `/auth/oidc/callback` - コールバック処理
3. 基本的なユーザー情報同期

### **Phase 2: 設定・運用**
4. `/auth/oidc/config` - 設定情報提供
5. エラーハンドリングの充実

### **Phase 3: 高度な機能**
6. `/auth/oidc/logout` - SSOログアウト
7. 監査ログの拡張

この設計により、既存の認証システムを活かしながら、最小限の変更でHENNGE Access ControlとのOIDC連携が実現できます。段階的な実装により、リスクを最小化しながら機能を追加していくことが可能です。

---

